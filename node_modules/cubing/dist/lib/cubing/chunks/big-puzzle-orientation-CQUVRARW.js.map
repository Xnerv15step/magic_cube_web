{
  "version": 3,
  "sources": ["../../../../src/cubing/puzzles/implementations/dynamic/big-cubes/big-puzzle-orientation.ts"],
  "sourcesContent": ["import { Alg, Grouping } from \"../../../../alg\";\nimport type { KPattern, KPuzzle } from \"../../../../kpuzzle\";\n\nexport function puzzleOrientationBigCubeIdx(\n  pattern: KPattern,\n): [number, number] {\n  const idxUFR = pattern.patternData[\"CORNERS\"].pieces[0];\n  const oriUFR = pattern.patternData[\"CORNERS\"].orientation[0];\n  return [idxUFR, oriUFR];\n}\n\nconst puzzleOrientationBigCubeCacheRaw: Alg[][] = new Array(8)\n  .fill(0)\n  .map(() => {\n    return new Array<Alg>(3);\n  });\n\nconst puzzleOrientationBigCubeCacheInitialized = false;\nexport function puzzleOrientationBigCubeCache(\n  bigCubeKPuzzle: KPuzzle, // TODO\n): Alg[][] {\n  if (!puzzleOrientationBigCubeCacheInitialized) {\n    // We use a new block to avoid keeping a reference to temporary vars.\n    // kpuzzle todo\n    {\n      const uAlgs: Alg[] = [\n        \"\",\n        \"y\",\n        \"y2\",\n        \"y'\",\n        \"x2\",\n        \"x2 y\",\n        \"x2 y2\",\n        \"x2 y'\",\n      ].map((s) => Alg.fromString(s));\n      const UFRAlg = new Alg(\"Rv Uv\");\n      for (const uAlg of uAlgs) {\n        let transformation = bigCubeKPuzzle.algToTransformation(uAlg);\n        for (let i = 0; i < 4; i++) {\n          const [idxUFR, oriUFR] = puzzleOrientationBigCubeIdx(\n            transformation.toKPattern(),\n          );\n          puzzleOrientationBigCubeCacheRaw[idxUFR][oriUFR] = new Alg([\n            ...uAlg.childAlgNodes(),\n            new Grouping(UFRAlg, i), // TODO: make this more efficient\n          ]).invert();\n          if (i === 3) {\n            // Avoid an unnecessary transformation calculation.\n            break;\n          }\n          transformation = transformation.applyAlg(UFRAlg);\n        }\n      }\n    }\n  }\n  return puzzleOrientationBigCubeCacheRaw;\n}\n\nexport function normalizeBigCubeOrientation(pattern: KPattern): KPattern {\n  const [idxUFR, oriUFR] = puzzleOrientationBigCubeIdx(pattern);\n  const orientationAlg = puzzleOrientationBigCubeCache(pattern.kpuzzle)[idxUFR][\n    oriUFR\n  ];\n  return pattern.applyAlg(orientationAlg);\n}\n\n// The `options` argument is required for now, because we haven't yet come up\n// with a general way to specify different kinds of solved for the same puzle.\nexport function experimentalIsBigCubeSolved(\n  pattern: KPattern,\n  options: {\n    ignorePuzzleOrientation: boolean;\n    ignoreCenterOrientation: boolean; // Unused for 4\u00D74\u00D74\n  },\n): boolean {\n  if (options.ignorePuzzleOrientation) {\n    pattern = normalizeBigCubeOrientation(pattern);\n  }\n  return pattern.isIdentical(pattern.kpuzzle.defaultPattern());\n}\n"],
  "mappings": ";;;;;;AAGO,SAAS,4BACd,SACkB;AAClB,QAAM,SAAS,QAAQ,YAAY,SAAS,EAAE,OAAO,CAAC;AACtD,QAAM,SAAS,QAAQ,YAAY,SAAS,EAAE,YAAY,CAAC;AAC3D,SAAO,CAAC,QAAQ,MAAM;AACxB;AAEA,IAAM,mCAA4C,IAAI,MAAM,CAAC,EAC1D,KAAK,CAAC,EACN,IAAI,MAAM;AACT,SAAO,IAAI,MAAW,CAAC;AACzB,CAAC;AAEH,IAAM,2CAA2C;AAC1C,SAAS,8BACd,gBACS;AACT,MAAI,CAAC,0CAA0C;AAG7C;AACE,YAAM,QAAe;AAAA,QACnB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,EAAE,IAAI,CAAC,MAAM,IAAI,WAAW,CAAC,CAAC;AAC9B,YAAM,SAAS,IAAI,IAAI,OAAO;AAC9B,iBAAW,QAAQ,OAAO;AACxB,YAAI,iBAAiB,eAAe,oBAAoB,IAAI;AAC5D,iBAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,gBAAM,CAAC,QAAQ,MAAM,IAAI;AAAA,YACvB,eAAe,WAAW;AAAA,UAC5B;AACA,2CAAiC,MAAM,EAAE,MAAM,IAAI,IAAI,IAAI;AAAA,YACzD,GAAG,KAAK,cAAc;AAAA,YACtB,IAAI,SAAS,QAAQ,CAAC;AAAA;AAAA,UACxB,CAAC,EAAE,OAAO;AACV,cAAI,MAAM,GAAG;AAEX;AAAA,UACF;AACA,2BAAiB,eAAe,SAAS,MAAM;AAAA,QACjD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAEO,SAAS,4BAA4B,SAA6B;AACvE,QAAM,CAAC,QAAQ,MAAM,IAAI,4BAA4B,OAAO;AAC5D,QAAM,iBAAiB,8BAA8B,QAAQ,OAAO,EAAE,MAAM,EAC1E,MACF;AACA,SAAO,QAAQ,SAAS,cAAc;AACxC;AAIO,SAAS,4BACd,SACA,SAIS;AACT,MAAI,QAAQ,yBAAyB;AACnC,cAAU,4BAA4B,OAAO;AAAA,EAC/C;AACA,SAAO,QAAQ,YAAY,QAAQ,QAAQ,eAAe,CAAC;AAC7D;",
  "names": []
}
