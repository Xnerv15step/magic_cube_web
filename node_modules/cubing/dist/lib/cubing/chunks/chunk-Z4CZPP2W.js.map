{
  "version": 3,
  "sources": ["../../../../src/cubing/vendor/mit/p-lazy/p-lazy.ts", "../../../../src/cubing/puzzles/stickerings/mask.ts", "../../../../src/cubing/puzzles/stickerings/puzzle-stickerings.ts", "../../../../src/cubing/puzzles/stickerings/cube-like-stickerings.ts", "../../../../src/cubing/puzzles/async/lazy-cached.ts", "../../../../src/cubing/puzzles/async/async-pg3d.ts", "../../../../src/cubing/puzzles/implementations/dynamic/3x3x3/3x3x3.kpuzzle.json.ts", "../../../../src/cubing/puzzles/implementations/dynamic/3x3x3/puzzle-orientation.ts", "../../../../src/cubing/puzzles/PuzzleLoader.ts", "../../../../src/cubing/puzzles/transformAlg.ts", "../../../../src/cubing/puzzles/customPGPuzzleLoader.ts", "../../../../src/cubing/puzzles/implementations/dynamic/2x2x2/puzzle-orientation.ts", "../../../../src/cubing/puzzles/cubing-private/index.ts", "../../../../src/cubing/puzzles/implementations/3x3x3/cube3x3x3KeyMapping.ts", "../../../../src/cubing/puzzles/implementations/3x3x3/puzzle-specific-simplifications.ts", "../../../../src/cubing/puzzles/implementations/3x3x3/index.ts"],
  "sourcesContent": ["// @ts-nocheck\n\nexport class PLazy<T> extends Promise<T> {\n  constructor(executor) {\n    super((resolve) => {\n      resolve();\n    });\n\n    this._executor = executor;\n  }\n\n  static from(function_) {\n    return new PLazy((resolve) => {\n      resolve(function_());\n    });\n  }\n\n  static resolve(value) {\n    return new PLazy((resolve) => {\n      resolve(value);\n    });\n  }\n\n  static reject(error) {\n    return new PLazy((_resolve, reject) => {\n      reject(error);\n    });\n  }\n\n  // biome-ignore lint/suspicious/noThenProperty: This is implementing the `Promise` API.\n  then(onFulfilled, onRejected) {\n    this._promise = this._promise || new Promise(this._executor);\n\n    return this._promise.then(onFulfilled, onRejected);\n  }\n\n  catch(onRejected) {\n    this._promise = this._promise || new Promise(this._executor);\n\n    return this._promise.catch(onRejected);\n  }\n}\n\nexport function from<T>(function_): Promise<T> {\n  return new PLazy((resolve) => {\n    resolve(function_());\n  });\n}\n", "// TODO: figure out where to house this permanently.\n\nimport type { Move } from \"../../alg\";\nimport type { KPuzzle } from \"../../kpuzzle\";\n\nexport type FaceletMeshStickeringMask =\n  | \"regular\"\n  | \"dim\"\n  | \"oriented\"\n  | \"experimentalOriented2\" // TODO\n  | \"ignored\"\n  | \"invisible\"\n  | \"mystery\";\n\nexport type FaceletStickeringMask = {\n  mask: FaceletMeshStickeringMask;\n  hintMask?: FaceletMeshStickeringMask;\n};\n\nexport type PieceStickeringMask = {\n  // TODO: foundation?\n  facelets: (FaceletMeshStickeringMask | FaceletStickeringMask | null)[];\n};\n\nexport type OrbitStickeringMask = {\n  pieces: (PieceStickeringMask | null)[];\n};\n\nexport type StickeringMask = {\n  specialBehaviour?: \"picture\"; // TODO: remove this\n  name?: string; // TODO\n  orbits: Record<string, OrbitStickeringMask>;\n};\n\nexport function getFaceletStickeringMask(\n  stickeringMask: StickeringMask,\n  orbitName: string,\n  pieceIdx: number,\n  faceletIdx: number,\n  hint: boolean,\n): FaceletMeshStickeringMask {\n  const orbitStickeringMask = stickeringMask.orbits[orbitName];\n  const pieceStickeringMask: PieceStickeringMask | null =\n    orbitStickeringMask.pieces[pieceIdx];\n  if (pieceStickeringMask === null) {\n    return regular;\n  }\n  const faceletStickeringMask:\n    | FaceletMeshStickeringMask\n    | FaceletStickeringMask\n    | null = pieceStickeringMask.facelets?.[faceletIdx];\n  if (faceletStickeringMask === null) {\n    return regular;\n  }\n  if (typeof faceletStickeringMask === \"string\") {\n    return faceletStickeringMask;\n  }\n  if (hint) {\n    return faceletStickeringMask.hintMask ?? faceletStickeringMask.mask;\n  }\n  console.log(faceletStickeringMask);\n  return faceletStickeringMask.mask;\n}\n\n// TODO: Revert this to a normal enum, or write a standard to codify the names?\nexport enum PieceStickering {\n  Regular = \"Regular\",\n  Dim = \"Dim\",\n  Ignored = \"Ignored\",\n  OrientationStickers = \"OrientationStickers\",\n  Invisible = \"Invisible\",\n  Ignoriented = \"Ignoriented\",\n  IgnoreNonPrimary = \"IgnoreNonPrimary\",\n  PermuteNonPrimary = \"PermuteNonPrimary\",\n  OrientationWithoutPermutation = \"OrientationWithoutPermutation\",\n  ExperimentalOrientationWithoutPermutation2 = \"ExperimentalOrientationWithoutPermutation2\", // TODO\n  Mystery = \"Mystery\", // TODO\n}\n\nexport class PieceAnnotation<T> {\n  stickerings: Map<string, T[]> = new Map();\n  constructor(kpuzzle: KPuzzle, defaultValue: T) {\n    for (const orbitDefinition of kpuzzle.definition.orbits) {\n      this.stickerings.set(\n        orbitDefinition.orbitName,\n        new Array(orbitDefinition.numPieces).fill(defaultValue),\n      );\n    }\n  }\n}\n\nconst regular = \"regular\";\nconst ignored = \"ignored\";\nconst oriented = \"oriented\";\nconst experimentalOriented2 = \"experimentalOriented2\";\nconst invisible = \"invisible\";\nconst dim = \"dim\";\nconst mystery = \"mystery\";\n\n// We specify 5 facelets, because that's the maximum we need for any built-in puzzles (e.g. Megaminx centers or icosa vertices).\n// TODO: use \"primary\" and \"non-primary\" fields instead of listing all non-primary facelets.\nconst pieceStickerings: Record<string, PieceStickeringMask> = {\n  // regular\n  [PieceStickering.Regular]: {\n    // r\n    facelets: [regular, regular, regular, regular, regular],\n  },\n\n  // ignored\n  [PieceStickering.Ignored]: {\n    // i\n    facelets: [ignored, ignored, ignored, ignored, ignored],\n  },\n\n  // oriented stickers\n  [PieceStickering.OrientationStickers]: {\n    // o\n    facelets: [oriented, oriented, oriented, oriented, oriented],\n  },\n\n  // \"OLL\"\n  [PieceStickering.IgnoreNonPrimary]: {\n    // riiii\n    facelets: [regular, ignored, ignored, ignored, ignored],\n  },\n\n  // invisible\n  [PieceStickering.Invisible]: {\n    // invisiblePiece\n    facelets: [invisible, invisible, invisible, invisible, invisible],\n  },\n\n  // \"PLL\"\n  [PieceStickering.PermuteNonPrimary]: {\n    // drrrr\n    facelets: [dim, regular, regular, regular, regular],\n  },\n\n  // ignored\n  [PieceStickering.Dim]: {\n    // d\n    facelets: [dim, dim, dim, dim, dim],\n  },\n\n  // \"OLL\"\n  [PieceStickering.Ignoriented]: {\n    // diiii\n    facelets: [dim, ignored, ignored, ignored, ignored],\n  },\n  [PieceStickering.OrientationWithoutPermutation]: {\n    // oiiii\n    facelets: [oriented, ignored, ignored, ignored, ignored],\n  },\n  [PieceStickering.ExperimentalOrientationWithoutPermutation2]: {\n    // oiiii\n    facelets: [experimentalOriented2, ignored, ignored, ignored, ignored],\n  },\n  [PieceStickering.Mystery]: {\n    // oiiii\n    facelets: [mystery, mystery, mystery, mystery, mystery],\n  },\n};\n\nexport function getPieceStickeringMask(\n  pieceStickering: PieceStickering,\n): PieceStickeringMask {\n  return pieceStickerings[pieceStickering];\n}\n\nexport class PuzzleStickering extends PieceAnnotation<PieceStickering> {\n  constructor(kpuzzle: KPuzzle) {\n    super(kpuzzle, PieceStickering.Regular);\n  }\n\n  set(pieceSet: PieceSet, pieceStickering: PieceStickering): PuzzleStickering {\n    for (const [orbitName, pieces] of this.stickerings.entries()) {\n      for (let i = 0; i < pieces.length; i++) {\n        if (pieceSet.stickerings.get(orbitName)![i]) {\n          pieces[i] = pieceStickering;\n        }\n      }\n    }\n    return this;\n  }\n\n  toStickeringMask(): StickeringMask {\n    const stickeringMask: StickeringMask = { orbits: {} };\n    for (const [orbitName, pieceStickerings] of this.stickerings.entries()) {\n      const pieces: PieceStickeringMask[] = [];\n      const orbitStickeringMask: OrbitStickeringMask = {\n        pieces,\n      };\n      stickeringMask.orbits[orbitName] = orbitStickeringMask;\n      for (const pieceStickering of pieceStickerings) {\n        pieces.push(getPieceStickeringMask(pieceStickering));\n      }\n    }\n    return stickeringMask;\n  }\n}\n\nexport type PieceSet = PieceAnnotation<boolean>;\n\nexport class StickeringManager {\n  constructor(private kpuzzle: KPuzzle) {}\n\n  and(pieceSets: PieceSet[]): PieceSet {\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitDefinition of this.kpuzzle.definition.orbits) {\n      pieceLoop: for (let i = 0; i < orbitDefinition.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitDefinition.orbitName)![i] = true;\n        for (const pieceSet of pieceSets) {\n          if (!pieceSet.stickerings.get(orbitDefinition.orbitName)![i]) {\n            newPieceSet.stickerings.get(orbitDefinition.orbitName)![i] = false;\n            continue pieceLoop;\n          }\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  or(pieceSets: PieceSet[]): PieceSet {\n    // TODO: unify impl with and?\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitDefinition of this.kpuzzle.definition.orbits) {\n      pieceLoop: for (let i = 0; i < orbitDefinition.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitDefinition.orbitName)![i] = false;\n        for (const pieceSet of pieceSets) {\n          if (pieceSet.stickerings.get(orbitDefinition.orbitName)![i]) {\n            newPieceSet.stickerings.get(orbitDefinition.orbitName)![i] = true;\n            continue pieceLoop;\n          }\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  not(pieceSet: PieceSet): PieceSet {\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitDefinition of this.kpuzzle.definition.orbits) {\n      for (let i = 0; i < orbitDefinition.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitDefinition.orbitName)![i] =\n          !pieceSet.stickerings.get(orbitDefinition.orbitName)![i];\n      }\n    }\n    return newPieceSet;\n  }\n\n  all(): PieceSet {\n    return this.and(this.moves([])); // TODO: are the degenerate cases for and/or the wrong way around\n  }\n\n  move(moveSource: Move | string): PieceSet {\n    const transformation = this.kpuzzle.moveToTransformation(moveSource);\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitDefinition of this.kpuzzle.definition.orbits) {\n      for (let i = 0; i < orbitDefinition.numPieces; i++) {\n        if (\n          transformation.transformationData[orbitDefinition.orbitName]\n            .permutation[i] !== i ||\n          transformation.transformationData[orbitDefinition.orbitName]\n            .orientationDelta[i] !== 0\n        ) {\n          newPieceSet.stickerings.get(orbitDefinition.orbitName)![i] = true;\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  moves(moveSources: (Move | string)[]): PieceSet[] {\n    return moveSources.map((moveSource) => this.move(moveSource));\n  }\n\n  orbits(orbitNames: string[]): PieceSet {\n    const pieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitName of orbitNames) {\n      pieceSet.stickerings.get(orbitName)!.fill(true);\n    }\n    return pieceSet;\n  }\n\n  orbitPrefix(orbitPrefix: string): PieceSet {\n    const pieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitDefinition of this.kpuzzle.definition.orbits) {\n      if (orbitDefinition.orbitName.startsWith(orbitPrefix)) {\n        pieceSet.stickerings.get(orbitDefinition.orbitName)!.fill(true);\n      }\n    }\n    return pieceSet;\n  }\n  // trueCounts(pieceSet: PieceSet): Record<string, number> {\n  //   const counts: Record<string, number> = {};\n  //   for (const orbitDefinition of this.def.orbits) {\n  //     let count = 0;\n  //     for (let i = 0; i < orbitDefinition.numPieces; i++) {\n  //       if (pieceSet.stickerings.get(orbitDefinition.orbitName)![i]) {\n  //         count++;\n  //       }\n  //     }\n  //     counts[orbitName] = count;\n  //   }\n  //   return counts;\n  // }\n}\n", "import type { PuzzleID } from \"../../twisty\";\n\nconst LL = \"Last Layer\";\nconst LS = \"Last Slot\";\nconst megaAnd3x3x3LL = {\n  \"3x3x3\": LL,\n  megaminx: LL,\n};\nconst megaAnd3x3x3LS = {\n  \"3x3x3\": LS,\n  megaminx: LS,\n};\n\nexport const experimentalStickerings: Record<\n  string,\n  { groups?: Partial<Record<PuzzleID, string>> }\n> = {\n  full: { groups: { \"3x3x3\": \"Stickering\", megaminx: \"Stickering\" } }, // default\n  OLL: { groups: megaAnd3x3x3LL },\n  PLL: { groups: megaAnd3x3x3LL },\n  LL: { groups: megaAnd3x3x3LL },\n  EOLL: { groups: megaAnd3x3x3LL },\n  COLL: { groups: megaAnd3x3x3LL },\n  OCLL: { groups: megaAnd3x3x3LL },\n  CPLL: { groups: megaAnd3x3x3LL },\n  CLL: { groups: megaAnd3x3x3LL },\n  EPLL: { groups: megaAnd3x3x3LL },\n  ELL: { groups: megaAnd3x3x3LL },\n  ZBLL: { groups: megaAnd3x3x3LL },\n  LS: { groups: megaAnd3x3x3LS },\n  LSOLL: { groups: megaAnd3x3x3LS },\n  LSOCLL: { groups: megaAnd3x3x3LS },\n  ELS: { groups: megaAnd3x3x3LS },\n  CLS: { groups: megaAnd3x3x3LS },\n  ZBLS: { groups: megaAnd3x3x3LS },\n  VLS: { groups: megaAnd3x3x3LS },\n  WVLS: { groups: megaAnd3x3x3LS },\n  F2L: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  Daisy: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  Cross: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  EO: { groups: { \"3x3x3\": \"ZZ\" } },\n  EOline: { groups: { \"3x3x3\": \"ZZ\" } },\n  EOcross: { groups: { \"3x3x3\": \"ZZ\" } },\n  FirstBlock: { groups: { \"3x3x3\": \"Roux\" } },\n  SecondBlock: { groups: { \"3x3x3\": \"Roux\" } },\n  CMLL: { groups: { \"3x3x3\": \"Roux\" } },\n  L10P: { groups: { \"3x3x3\": \"Roux\" } },\n  L6E: { groups: { \"3x3x3\": \"Roux\" } },\n  L6EO: { groups: { \"3x3x3\": \"Roux\" } },\n  \"2x2x2\": { groups: { \"3x3x3\": \"Petrus\" } },\n  \"2x2x3\": { groups: { \"3x3x3\": \"Petrus\" } },\n  EODF: { groups: { \"3x3x3\": \"Nautilus\" } },\n  G1: { groups: { \"3x3x3\": \"FMC\" } },\n  L2C: {\n    groups: {\n      \"4x4x4\": \"Reduction\",\n      \"5x5x5\": \"Reduction\",\n      \"6x6x6\": \"Reduction\",\n    },\n  },\n  PBL: {\n    groups: {\n      \"2x2x2\": \"Ortega\",\n    },\n  },\n  \"Void Cube\": { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  invisible: { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  picture: { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  \"centers-only\": { groups: { \"3x3x3\": \"Miscellaneous\" } }, // TODO\n  \"opposite-centers\": { groups: { \"4x4x4\": \"Reduction\" } }, // TODO\n  \"experimental-centers-U\": {},\n  \"experimental-centers-U-D\": {},\n  \"experimental-centers-U-L-D\": {},\n  \"experimental-centers-U-L-B-D\": {},\n  \"experimental-centers\": {},\n  \"experimental-fto-fc\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-f2t\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-sc\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-l2c\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-lbt\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-l3t\": { groups: { fto: \"Bencisco\" } },\n};\n", "import type { ExperimentalStickering, PuzzleID } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport {\n  type PieceSet,\n  PieceStickering,\n  PuzzleStickering,\n  StickeringManager,\n  type StickeringMask,\n} from \"./mask\";\nimport { experimentalStickerings } from \"./puzzle-stickerings\";\n\nexport async function cubeLikeStickeringMask(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<StickeringMask> {\n  return (\n    await cubeLikePuzzleStickering(puzzleLoader, stickering)\n  ).toStickeringMask();\n}\n\n// TODO: cache calculations?\nexport async function cubeLikePuzzleStickering(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<PuzzleStickering> {\n  const kpuzzle = await puzzleLoader.kpuzzle();\n  const puzzleStickering = new PuzzleStickering(kpuzzle);\n  const m = new StickeringManager(kpuzzle);\n\n  const LL = (): PieceSet => m.move(\"U\");\n  const orUD = (): PieceSet => m.or(m.moves([\"U\", \"D\"]));\n  const orLR = (): PieceSet => m.or(m.moves([\"L\", \"R\"]));\n  const M = (): PieceSet => m.not(orLR());\n\n  const F2L = (): PieceSet => m.not(LL());\n\n  const CENTERS = (): PieceSet => m.orbitPrefix(\"CENTER\");\n  const CENTER = (faceMove: string): PieceSet =>\n    m.and([m.move(faceMove), CENTERS()]);\n  const EDGES = (): PieceSet => m.orbitPrefix(\"EDGE\");\n  const EDGE = (faceMoves: string[]): PieceSet =>\n    m.and([m.and(m.moves(faceMoves)), EDGES()]);\n  const CORNERS = (): PieceSet =>\n    m.or([\n      m.orbitPrefix(\"CORNER\"),\n      m.orbitPrefix(\"C4RNER\"),\n      m.orbitPrefix(\"C5RNER\"),\n    ]);\n\n  const L6E = (): PieceSet => m.or([M(), m.and([LL(), EDGES()])]);\n  const centerLL = (): PieceSet => m.and([LL(), CENTERS()]);\n\n  const edgeFR = (): PieceSet => m.and([m.and(m.moves([\"F\", \"R\"])), EDGES()]);\n  // Handles Megaminx\n  const cornerDFR = (): PieceSet =>\n    m.and([m.and(m.moves([\"F\", \"R\"])), CORNERS(), m.not(LL())]);\n  const slotFR = (): PieceSet => m.or([cornerDFR(), edgeFR()]);\n\n  function dimF2L(): void {\n    puzzleStickering.set(F2L(), PieceStickering.Dim);\n  }\n\n  function setPLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.PermuteNonPrimary);\n    puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n  }\n\n  function setOLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.IgnoreNonPrimary);\n    puzzleStickering.set(centerLL(), PieceStickering.Regular); // For PG\n  }\n\n  function dimOLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.Ignoriented);\n    puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n  }\n\n  switch (stickering) {\n    case \"full\":\n      break;\n    case \"PLL\": {\n      dimF2L();\n      setPLL();\n      break;\n    }\n    case \"CLS\": {\n      dimF2L();\n      puzzleStickering.set(cornerDFR(), PieceStickering.Regular);\n      puzzleStickering.set(LL(), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"OLL\": {\n      dimF2L();\n      setOLL();\n      break;\n    }\n    case \"EOLL\": {\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      break;\n    }\n    case \"COLL\": {\n      dimF2L();\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    }\n    case \"OCLL\": {\n      dimF2L();\n      dimOLL();\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"CPLL\": {\n      dimF2L();\n      puzzleStickering.set(\n        m.and([CORNERS(), LL()]),\n        PieceStickering.PermuteNonPrimary,\n      );\n      puzzleStickering.set(\n        m.and([m.not(CORNERS()), LL()]),\n        PieceStickering.Dim,\n      );\n      break;\n    }\n    case \"CLL\": {\n      dimF2L();\n      puzzleStickering.set(\n        m.not(m.and([CORNERS(), LL()])),\n        PieceStickering.Dim,\n      );\n      break;\n    }\n    case \"EPLL\": {\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), EDGES()]),\n        PieceStickering.PermuteNonPrimary,\n      );\n      break;\n    }\n    case \"ELL\": {\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.Dim);\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Regular);\n      break;\n    }\n    case \"ELS\": {\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      puzzleStickering.set(edgeFR(), PieceStickering.Regular);\n      puzzleStickering.set(cornerDFR(), PieceStickering.Ignored);\n      break;\n    }\n    case \"LL\": {\n      dimF2L();\n      break;\n    }\n    case \"F2L\": {\n      puzzleStickering.set(LL(), PieceStickering.Ignored);\n      break;\n    }\n    case \"ZBLL\": {\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.PermuteNonPrimary);\n      puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    }\n    case \"ZBLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      break;\n    }\n    case \"VLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      setOLL();\n      break;\n    }\n    case \"WVLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"LS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      puzzleStickering.set(LL(), PieceStickering.Ignored);\n      puzzleStickering.set(centerLL(), PieceStickering.Dim);\n      break;\n    }\n    case \"LSOLL\": {\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      break;\n    }\n    case \"LSOCLL\": {\n      dimF2L();\n      dimOLL();\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      break;\n    }\n    case \"EO\": {\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      break;\n    }\n    case \"EOline\": {\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.and(m.moves([\"D\", \"M\"])), PieceStickering.Regular);\n      break;\n    }\n    case \"EOcross\": {\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.move(\"D\"), PieceStickering.Regular);\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      break;\n    }\n    case \"CMLL\": {\n      puzzleStickering.set(F2L(), PieceStickering.Dim);\n      puzzleStickering.set(L6E(), PieceStickering.Ignored);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    }\n    case \"L10P\": {\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      puzzleStickering.set(m.and([CORNERS(), LL()]), PieceStickering.Regular);\n      break;\n    }\n    case \"L6E\": {\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      break;\n    }\n    case \"L6EO\": {\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      puzzleStickering.set(\n        L6E(),\n        PieceStickering.ExperimentalOrientationWithoutPermutation2,\n      );\n      puzzleStickering.set(\n        m.and([CENTERS(), orUD()]),\n        PieceStickering.ExperimentalOrientationWithoutPermutation2,\n      ); // For PG\n      puzzleStickering.set(\n        m.and([m.move(\"M\"), m.move(\"E\")]),\n        PieceStickering.Ignored,\n      );\n      break;\n    }\n    case \"Daisy\": {\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(CENTERS(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"U\"), EDGES()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"Cross\": {\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(CENTERS(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), EDGES()]),\n        PieceStickering.Regular,\n      );\n      break;\n    }\n    case \"2x2x2\": {\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        PieceStickering.Dim,\n      );\n      break;\n    }\n    case \"2x2x3\": {\n      puzzleStickering.set(m.all(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        PieceStickering.Dim,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"F\"), m.not(m.or(m.moves([\"U\", \"R\"])))]),\n        PieceStickering.Regular,\n      );\n      break;\n    }\n    case \"G1\": {\n      puzzleStickering.set(\n        m.all(),\n        PieceStickering.ExperimentalOrientationWithoutPermutation2,\n      );\n      puzzleStickering.set(\n        m.or(m.moves([\"E\"])),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.and(m.moves([\"E\", \"S\"])), PieceStickering.Ignored);\n      break;\n    }\n    case \"L2C\": {\n      puzzleStickering.set(\n        m.or(m.moves([\"L\", \"R\", \"B\", \"D\"])),\n        PieceStickering.Dim,\n      );\n      puzzleStickering.set(m.not(CENTERS()), PieceStickering.Ignored);\n      break;\n    }\n    case \"PBL\": {\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"D\"])),\n        PieceStickering.PermuteNonPrimary,\n      );\n      break;\n    }\n    case \"FirstBlock\": {\n      puzzleStickering.set(\n        m.not(m.and([m.and(m.moves([\"L\"])), m.not(LL())])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(CENTER(\"R\"), PieceStickering.Dim);\n      break;\n    }\n    case \"SecondBlock\": {\n      puzzleStickering.set(\n        m.not(m.and([m.and(m.moves([\"L\"])), m.not(LL())])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.and(m.moves([\"L\"])), m.not(LL())]),\n        PieceStickering.Dim,\n      );\n      puzzleStickering.set(\n        m.and([m.and(m.moves([\"R\"])), m.not(LL())]),\n        PieceStickering.Regular,\n      );\n      break;\n    }\n    case \"EODF\": {\n      dimF2L();\n      puzzleStickering.set(\n        m.or([cornerDFR(), m.and([LL(), CORNERS()])]),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.or([m.and([LL(), EDGES()]), edgeFR()]),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(EDGE([\"D\", \"F\"]), PieceStickering.Regular);\n      puzzleStickering.set(CENTER(\"F\"), PieceStickering.Regular);\n      break;\n    }\n    case \"Void Cube\": {\n      puzzleStickering.set(CENTERS(), PieceStickering.Invisible);\n      break;\n    }\n    case \"picture\":\n    // fallthrough\n    case \"invisible\": {\n      puzzleStickering.set(m.all(), PieceStickering.Invisible);\n      break;\n    }\n    case \"centers-only\": {\n      puzzleStickering.set(m.not(CENTERS()), PieceStickering.Ignored);\n      break;\n    }\n    case \"opposite-centers\": {\n      puzzleStickering.set(\n        m.not(m.and([CENTERS(), m.or(m.moves([\"U\", \"D\"]))])),\n        PieceStickering.Ignored,\n      );\n      break;\n    }\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n      );\n      puzzleStickering.set(m.and(m.moves([])), PieceStickering.Dim);\n  }\n  return puzzleStickering;\n}\n\nexport async function cubeLikeStickeringList(\n  puzzleID: PuzzleID,\n  options?: { use3x3x3Fallbacks: boolean },\n): Promise<ExperimentalStickering[]> {\n  const stickerings: ExperimentalStickering[] = [];\n  const stickeringsFallback: ExperimentalStickering[] = [];\n  for (const [name, info] of Object.entries(experimentalStickerings)) {\n    if (info.groups) {\n      if (puzzleID in info.groups) {\n        stickerings.push(name);\n      } else if (options?.use3x3x3Fallbacks && \"3x3x3\" in info.groups) {\n        stickeringsFallback.push(name);\n      }\n    }\n  }\n  return stickerings.concat(stickeringsFallback);\n}\n", "export function getCached<T>(getValue: () => Promise<T>): () => Promise<T> {\n  let cachedPromise: Promise<T> | null = null;\n  return (): Promise<T> => {\n    return (cachedPromise ??= getValue());\n  };\n}\n", "import {\n  Move,\n  type PuzzleSpecificSimplifyOptions,\n  type QuantumMove,\n} from \"../../alg\";\nimport { KPuzzle, type KPuzzleDefinition } from \"../../kpuzzle\";\nimport type { PuzzleGeometry } from \"../../puzzle-geometry\";\nimport type { ExperimentalStickering, PuzzleID } from \"../../twisty\";\nimport { PLazy } from \"../../vendor/mit/p-lazy/p-lazy\";\nimport { cubeMirrorTransforms } from \"../implementations/3x3x3\";\nimport type { AlgTransformData, PuzzleLoader } from \"../PuzzleLoader\";\nimport {\n  cubeLikeStickeringList,\n  cubeLikeStickeringMask,\n} from \"../stickerings/cube-like-stickerings\";\nimport type { StickeringMask } from \"../stickerings/mask\";\nimport { getCached } from \"./lazy-cached\";\n\n// TODO: modify this to handle TwistyPlayer options\nexport async function asyncGetPuzzleGeometry(\n  puzzleName: string,\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByName(puzzleName, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true,\n  });\n}\n\n// When we need a base puzzle (when a user wants GAP or Mathematica\n// or KSolve output), or if we want to run Schreier-Sims or such,\n// we need a default base puzzle to work with (for instance, 333\n// without slice moves or oriented centers  is what people expect).\n// This function lets those operations behave more in line with\n// what people want.\nasync function asyncGetBasePuzzleGeometry(\n  puzzleName: string,\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByName(puzzleName);\n}\n\n// TODO: can we cache the puzzleGeometry to avoid duplicate calls, without\n// wasting memory? Maybe just save the latest one for successive calls about the\n// same puzzle?\nexport async function asyncGetKPuzzle(\n  pgPromise: Promise<PuzzleGeometry>,\n  puzzleName: string,\n  setOrientationModTo1ForPiecesOfOrbits?: string[], // TODO: make this unhacky\n): Promise<KPuzzle> {\n  const pg = await pgPromise;\n  const kpuzzleDefinition: KPuzzleDefinition = pg.getKPuzzleDefinition(true);\n  kpuzzleDefinition.name = puzzleName;\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n    pg,\n    pg.getOrbitsDef(true),\n  );\n  if (setOrientationModTo1ForPiecesOfOrbits) {\n    const setOrientationModTo1ForPiecesOfOrbitsSet = new Set(\n      setOrientationModTo1ForPiecesOfOrbits,\n    );\n    for (const [orbitName, orbitData] of Object.entries(\n      kpuzzleDefinition.defaultPattern,\n    )) {\n      if (setOrientationModTo1ForPiecesOfOrbitsSet.has(orbitName)) {\n        orbitData.orientationMod = new Array(\n          orbitData.pieces.length, // TODO: get this from the orbit definition, especially once we allow empty entries.\n        ).fill(1);\n      }\n    }\n  }\n  return new KPuzzle(pgNotation.remapKPuzzleDefinition(kpuzzleDefinition), {\n    experimentalPGNotation: pgNotation,\n  });\n}\n\nexport function asyncLazyKPuzzleGetter(\n  pgPromise: Promise<PuzzleGeometry>,\n  puzzleName: string,\n): () => Promise<KPuzzle> {\n  return getCached(() => asyncGetKPuzzle(pgPromise, puzzleName));\n}\n\ntype PuzzleLoaderConstructorArgs = {\n  pgID?: string;\n  id: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number;\n  setOrientationModTo1ForPiecesOfOrbits?: string[];\n};\n\nexport class PGPuzzleLoader implements PuzzleLoader {\n  pgId?: string;\n  id: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number;\n  #setOrientationModTo1ForPiecesOfOrbits?: string[]; //  // TODO: make this unhacky\n  constructor(info: PuzzleLoaderConstructorArgs) {\n    this.pgId = info.pgID;\n    this.id = info.id;\n    this.fullName = info.fullName;\n    this.inventedBy = info.inventedBy;\n    this.inventionYear = info.inventionYear;\n    this.#setOrientationModTo1ForPiecesOfOrbits =\n      info.setOrientationModTo1ForPiecesOfOrbits;\n  }\n\n  #cachedPG: Promise<PuzzleGeometry> | undefined;\n  pg(): Promise<PuzzleGeometry> {\n    return (this.#cachedPG ??= asyncGetPuzzleGeometry(this.pgId ?? this.id));\n  }\n\n  #cachedBasePG: Promise<PuzzleGeometry> | undefined;\n  basePG(): Promise<PuzzleGeometry> {\n    return (this.#cachedBasePG ??= asyncGetBasePuzzleGeometry(\n      this.pgId ?? this.id,\n    ));\n  }\n\n  #cachedKPuzzle: Promise<KPuzzle> | undefined;\n  kpuzzle(): Promise<KPuzzle> {\n    return (this.#cachedKPuzzle ??= asyncGetKPuzzle(\n      this.pg(),\n      this.id,\n      this.#setOrientationModTo1ForPiecesOfOrbits,\n    ));\n  }\n\n  #cachedSVG: Promise<string> | undefined;\n  svg(): Promise<string> {\n    return (this.#cachedSVG ??= (async () =>\n      (await this.pg()).generatesvg())());\n  }\n\n  puzzleSpecificSimplifyOptionsPromise = puzzleSpecificSimplifyOptionsPromise(\n    this.kpuzzle.bind(this),\n  );\n}\n\nexport class CubePGPuzzleLoader extends PGPuzzleLoader {\n  stickeringMask(stickering: ExperimentalStickering): Promise<StickeringMask> {\n    return cubeLikeStickeringMask(this, stickering);\n  }\n  stickerings = () =>\n    cubeLikeStickeringList(this.id as PuzzleID, { use3x3x3Fallbacks: true });\n  algTransformData: AlgTransformData = cubeMirrorTransforms;\n}\n\nexport function puzzleSpecificSimplifyOptionsPromise(\n  kpuzzlePromiseFn: () => Promise<KPuzzle>,\n): Promise<PuzzleSpecificSimplifyOptions> {\n  return new PLazy(\n    async (resolve: (options: PuzzleSpecificSimplifyOptions) => void) => {\n      const kpuzzle = await kpuzzlePromiseFn();\n      resolve({\n        quantumMoveOrder: (m: QuantumMove) => {\n          return kpuzzle.moveToTransformation(new Move(m)).repetitionOrder();\n        },\n      });\n    },\n  );\n}\n", "import type { KPuzzleDefinition } from \"../../../../kpuzzle\";\n\nexport const cube3x3x3KPuzzleDefinition: KPuzzleDefinition = {\n  name: \"3x3x3\",\n  orbits: [\n    { orbitName: \"EDGES\", numPieces: 12, numOrientations: 2 },\n    { orbitName: \"CORNERS\", numPieces: 8, numOrientations: 3 },\n    { orbitName: \"CENTERS\", numPieces: 6, numOrientations: 4 },\n  ],\n  defaultPattern: {\n    EDGES: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    },\n    CORNERS: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n    },\n    CENTERS: {\n      pieces: [0, 1, 2, 3, 4, 5],\n      orientation: [0, 0, 0, 0, 0, 0],\n      orientationMod: [1, 1, 1, 1, 1, 1],\n    },\n  },\n  moves: {\n    U: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 8, 9, 10, 11],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientationDelta: [1, 0, 0, 0, 0, 0],\n      },\n    },\n    y: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 5, 6, 7, 4, 10, 8, 11, 9],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 7, 4, 5, 6],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientationDelta: [1, 0, 0, 0, 0, 3],\n      },\n    },\n    x: {\n      EDGES: {\n        permutation: [4, 8, 0, 9, 6, 10, 2, 11, 5, 7, 1, 3],\n        orientationDelta: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 3, 5, 7, 6, 2, 1],\n        orientationDelta: [2, 1, 2, 1, 1, 2, 1, 2],\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientationDelta: [0, 3, 0, 1, 2, 2],\n      },\n    },\n    L: {\n      EDGES: {\n        permutation: [0, 1, 2, 11, 4, 5, 6, 9, 8, 3, 10, 7],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientationDelta: [0, 0, 2, 1, 0, 2, 1, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientationDelta: [0, 1, 0, 0, 0, 0],\n      },\n    },\n    F: {\n      EDGES: {\n        permutation: [9, 1, 2, 3, 8, 5, 6, 7, 0, 4, 10, 11],\n        orientationDelta: [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0],\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientationDelta: [1, 0, 0, 2, 2, 1, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientationDelta: [0, 0, 1, 0, 0, 0],\n      },\n    },\n    R: {\n      EDGES: {\n        permutation: [0, 8, 2, 3, 4, 10, 6, 7, 5, 9, 1, 11],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientationDelta: [2, 1, 0, 0, 1, 0, 0, 2],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientationDelta: [0, 0, 0, 1, 0, 0],\n      },\n    },\n    B: {\n      EDGES: {\n        permutation: [0, 1, 10, 3, 4, 5, 11, 7, 8, 9, 6, 2],\n        orientationDelta: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientationDelta: [0, 2, 1, 0, 0, 0, 2, 1],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientationDelta: [0, 0, 0, 0, 1, 0],\n      },\n    },\n    D: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 8, 9, 10, 11],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientationDelta: [0, 0, 0, 0, 0, 1],\n      },\n    },\n    z: {\n      EDGES: {\n        permutation: [9, 3, 11, 7, 8, 1, 10, 5, 0, 4, 2, 6],\n        orientationDelta: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [3, 2, 6, 5, 0, 4, 7, 1],\n        orientationDelta: [1, 2, 1, 2, 2, 1, 2, 1],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientationDelta: [1, 1, 1, 1, 3, 1],\n      },\n    },\n    M: {\n      EDGES: {\n        permutation: [2, 1, 6, 3, 0, 5, 4, 7, 8, 9, 10, 11],\n        orientationDelta: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientationDelta: [2, 0, 0, 0, 2, 0],\n      },\n    },\n    E: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 8, 10],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientationDelta: [0, 0, 0, 0, 0, 0],\n      },\n    },\n    S: {\n      EDGES: {\n        permutation: [0, 3, 2, 7, 4, 1, 6, 5, 8, 9, 10, 11],\n        orientationDelta: [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientationDelta: [1, 1, 0, 1, 0, 1],\n      },\n    },\n    u: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 10, 8, 11, 9],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientationDelta: [1, 0, 0, 0, 0, 0],\n      },\n    },\n    l: {\n      EDGES: {\n        permutation: [2, 1, 6, 11, 0, 5, 4, 9, 8, 3, 10, 7],\n        orientationDelta: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientationDelta: [0, 0, 2, 1, 0, 2, 1, 0],\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientationDelta: [2, 1, 0, 0, 2, 0],\n      },\n    },\n    f: {\n      EDGES: {\n        permutation: [9, 3, 2, 7, 8, 1, 6, 5, 0, 4, 10, 11],\n        orientationDelta: [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0],\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientationDelta: [1, 0, 0, 2, 2, 1, 0, 0],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientationDelta: [1, 1, 1, 1, 0, 1],\n      },\n    },\n    r: {\n      EDGES: {\n        permutation: [4, 8, 0, 3, 6, 10, 2, 7, 5, 9, 1, 11],\n        orientationDelta: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientationDelta: [2, 1, 0, 0, 1, 0, 0, 2],\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientationDelta: [0, 0, 0, 1, 2, 2],\n      },\n    },\n    b: {\n      EDGES: {\n        permutation: [0, 5, 10, 1, 4, 7, 11, 3, 8, 9, 6, 2],\n        orientationDelta: [0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientationDelta: [0, 2, 1, 0, 0, 0, 2, 1],\n      },\n      CENTERS: {\n        permutation: [3, 0, 2, 5, 4, 1],\n        orientationDelta: [3, 3, 0, 3, 1, 3],\n      },\n    },\n    d: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 9, 11, 8, 10],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientationDelta: [0, 0, 0, 0, 0, 1],\n      },\n    },\n  },\n  derivedMoves: {\n    Uw: \"u\",\n    Lw: \"l\",\n    Fw: \"f\",\n    Rw: \"r\",\n    Bw: \"b\",\n    Dw: \"d\",\n\n    Uv: \"y\",\n    Lv: \"x'\",\n    Fv: \"z\",\n    Rv: \"x\",\n    Bv: \"z'\",\n    Dv: \"y'\",\n\n    \"2U\": \"u U'\",\n    \"2L\": \"l L'\",\n    \"2F\": \"f F'\",\n    \"2R\": \"r R'\",\n    \"2B\": \"b B'\",\n    \"2D\": \"d D'\",\n  },\n};\n", "import { Alg } from \"../../../../alg\";\nimport { KPattern, type KTransformation } from \"../../../../kpuzzle\";\nimport { experimental3x3x3KPuzzle } from \"../../../cubing-private\";\n\nexport function puzzleOrientation3x3x3Idx(pattern: KPattern): [number, number] {\n  const idxU = pattern.patternData[\"CENTERS\"].pieces[0];\n  const idxD = pattern.patternData[\"CENTERS\"].pieces[5];\n  const unadjustedIdxL = pattern.patternData[\"CENTERS\"].pieces[1];\n  let idxL = unadjustedIdxL;\n  if (idxU < unadjustedIdxL) {\n    idxL--;\n  }\n  if (idxD < unadjustedIdxL) {\n    idxL--;\n  }\n  return [idxU, idxL];\n}\n\nconst puzzleOrientationCacheRaw: KTransformation[][] = new Array(6)\n  .fill(0)\n  .map(() => {\n    return new Array<KTransformation>(6);\n  });\n\nconst puzzleOrientationCacheInitialized = false;\nexport function puzzleOrientation3x3x3Cache(): KTransformation[][] {\n  if (!puzzleOrientationCacheInitialized) {\n    // We use a new block to avoid keeping a reference to temporary vars.\n    // kpuzzle todo\n    {\n      const uAlgs: Alg[] = [\"\", \"z\", \"x\", \"z'\", \"x'\", \"x2\"].map((s) =>\n        Alg.fromString(s),\n      );\n      const yAlg = new Alg(\"y\");\n      for (const uAlg of uAlgs) {\n        let transformation = experimental3x3x3KPuzzle.algToTransformation(uAlg);\n        for (let i = 0; i < 4; i++) {\n          transformation = transformation.applyAlg(yAlg);\n          const [idxU, idxL] = puzzleOrientation3x3x3Idx(\n            transformation.toKPattern(),\n          );\n          puzzleOrientationCacheRaw[idxU][idxL] = transformation.invert();\n        }\n      }\n    }\n  }\n  return puzzleOrientationCacheRaw;\n}\n\nexport function normalize3x3x3Orientation(pattern: KPattern): KPattern {\n  const [idxU, idxL] = puzzleOrientation3x3x3Idx(pattern);\n  const orientationTransformation = puzzleOrientation3x3x3Cache()[idxU][idxL];\n  return pattern.applyTransformation(orientationTransformation);\n}\n\n// The `options` argument is required for now, because we haven't yet come up\n// with a general way to specify different kinds of solved for the same puzle.\nexport function experimentalIs3x3x3Solved(\n  pattern: KPattern,\n  options: {\n    ignorePuzzleOrientation: boolean;\n    ignoreCenterOrientation: boolean;\n  },\n): boolean {\n  if (options.ignorePuzzleOrientation) {\n    pattern = normalize3x3x3Orientation(pattern);\n  }\n  // TODO(orientationMod)\n  if (options.ignoreCenterOrientation) {\n    pattern = new KPattern(pattern.kpuzzle, {\n      EDGES: pattern.patternData[\"EDGES\"],\n      CORNERS: pattern.patternData[\"CORNERS\"],\n      CENTERS: {\n        pieces: pattern.patternData[\"CENTERS\"].pieces,\n        orientation: new Array(6).fill(0),\n      },\n    });\n  }\n  return !!pattern.experimentalToTransformation()?.isIdentityTransformation(); // TODO: Compare to start state instead?\n}\n", "import type { AlgLeaf, PuzzleSpecificSimplifyOptions } from \"../alg\";\nimport type { AppendOptions } from \"../alg/simplify\";\nimport type { KPuzzle } from \"../kpuzzle\";\nimport type { PuzzleGeometry } from \"../puzzle-geometry\";\nimport type { ExperimentalStickering } from \"../twisty\";\nimport type { StickeringMask } from \"./stickerings/mask\";\n\nexport type KeyMapping = { [keyCode: string]: AlgLeaf };\n\nexport type AlgTransformData = Record<\n  string,\n  {\n    replaceMovesByFamily: Record<string, string>;\n    // - `undefined`: do not invert any moves\n    // - not `undefined`: invert any moves not in the set (simultaneous with any family replacement)\n    invertExceptByFamily?: Set<string>;\n  }\n>;\n\nexport interface PuzzleLoader {\n  id: string;\n  // shortName?: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number; // TODO: date?\n  /** @deprecated */\n  def?: never;\n  kpuzzle: () => Promise<KPuzzle>; // TODO\n  svg: () => Promise<string>;\n  llSVG?: () => Promise<string>;\n  llFaceSVG?: () => Promise<string>;\n  pg?: () => Promise<PuzzleGeometry>;\n  basePG?: () => Promise<PuzzleGeometry>;\n  stickeringMask?: (\n    stickering: ExperimentalStickering,\n  ) => Promise<StickeringMask>;\n  stickerings?: () => Promise<ExperimentalStickering[]>;\n  puzzleSpecificSimplifyOptions?: PuzzleSpecificSimplifyOptions;\n  puzzleSpecificSimplifyOptionsPromise?: Promise<PuzzleSpecificSimplifyOptions>; // TODO\n  keyMapping?: () => Promise<KeyMapping>; // TODO: async getter\n  algTransformData?: AlgTransformData;\n}\n\n// TODO: consolidate the `puzzleSpecificSimplifyOptionsPromise` with `puzzleSpecificSimplifyOptions` somehow, so that we don't have to do this.\nexport async function getPartialAppendOptionsForPuzzleSpecificSimplifyOptions(\n  puzzleLoader: PuzzleLoader,\n): Promise<AppendOptions> {\n  const puzzleSpecificSimplifyOptions =\n    await (puzzleLoader.puzzleSpecificSimplifyOptions ??\n      puzzleLoader.puzzleSpecificSimplifyOptionsPromise);\n  if (!puzzleSpecificSimplifyOptions) {\n    return {};\n  }\n  return { puzzleLoader: { puzzleSpecificSimplifyOptions } };\n}\n", "import type { AlgTransformData } from \"cubing/puzzles/cubing-private\";\nimport {\n  Alg,\n  type AlgNode,\n  Commutator,\n  Conjugate,\n  functionFromTraversal,\n  type Grouping,\n  type LineComment,\n  type Move,\n  type Newline,\n  type Pause,\n  TraversalDownUp,\n} from \"../alg\";\n\nclass TransformAlg extends TraversalDownUp<\n  AlgTransformData[string],\n  Alg,\n  AlgNode\n> {\n  public traverseAlg(alg: Alg, dataDown: AlgTransformData[string]): Alg {\n    const algNodes: AlgNode[] = [];\n    for (const algNode of alg.childAlgNodes()) {\n      algNodes.push(this.traverseAlgNode(algNode, dataDown));\n    }\n    return new Alg(algNodes);\n  }\n\n  public traverseGrouping(\n    grouping: Grouping,\n    dataDown: AlgTransformData[string],\n  ): AlgNode {\n    return grouping.modified({ alg: this.traverseAlg(grouping.alg, dataDown) });\n  }\n\n  public traverseMove(move: Move, dataDown: AlgTransformData[string]): AlgNode {\n    const invert = (() => {\n      const { invertExceptByFamily } = dataDown;\n      if (!invertExceptByFamily) {\n        return false;\n      }\n      return !invertExceptByFamily.has(move.family);\n    })();\n    return move.modified({\n      amount: invert ? -move.amount : move.amount,\n      family: dataDown.replaceMovesByFamily[move.family] ?? move.family,\n    });\n  }\n\n  public traverseCommutator(\n    commutator: Commutator,\n    dataDown: AlgTransformData[string],\n  ): AlgNode {\n    return new Commutator(\n      this.traverseAlg(commutator.A, dataDown),\n      this.traverseAlg(commutator.B, dataDown),\n    );\n  }\n\n  public traverseConjugate(\n    conjugate: Conjugate,\n    dataDown: AlgTransformData[string],\n  ): AlgNode {\n    return new Conjugate(\n      this.traverseAlg(conjugate.A, dataDown),\n      this.traverseAlg(conjugate.B, dataDown),\n    );\n  }\n\n  // TODO: Remove spaces between repeated pauses (in traverseSequence)\n  public traversePause(\n    pause: Pause,\n    _dataDown: AlgTransformData[string],\n  ): AlgNode {\n    return pause;\n  }\n\n  public traverseNewline(\n    newLine: Newline,\n    _dataDown: AlgTransformData[string],\n  ): AlgNode {\n    return newLine;\n  }\n\n  // TODO: Enforce being followed by a newline (or the end of the alg)?\n  public traverseLineComment(\n    comment: LineComment,\n    _dataDown: AlgTransformData[string],\n  ): AlgNode {\n    return comment;\n  }\n}\n\nexport const transformAlg = functionFromTraversal(TransformAlg);\n", "import type { KPuzzle } from \"../kpuzzle\";\nimport type { PuzzleGeometry } from \"../puzzle-geometry\";\nimport type { PuzzleDescriptionString } from \"../puzzle-geometry/PGPuzzles\";\nimport {\n  asyncGetKPuzzle,\n  puzzleSpecificSimplifyOptionsPromise,\n} from \"./async/async-pg3d\";\nimport type { PuzzleLoader } from \"./PuzzleLoader\";\n\n// TODO: modify this to handle TwistyPlayer options\nexport async function descAsyncGetPuzzleGeometry(\n  desc: PuzzleDescriptionString,\n  options?: {\n    includeCenterOrbits?: boolean;\n    includeEdgeOrbits?: boolean;\n    // TODO: expose the API better.\n    allMoves?: boolean;\n    orientCenters?: boolean;\n    addRotations?: boolean;\n  },\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByDesc(desc, {\n    allMoves: options?.allMoves ?? true,\n    orientCenters: options?.orientCenters ?? true,\n    addRotations: options?.addRotations ?? true,\n    ...options,\n  });\n}\n\nexport async function asyncGetKPuzzleByDesc(\n  desc: PuzzleDescriptionString,\n  options?: { includeCenterOrbits?: boolean; includeEdgeOrbits?: boolean },\n): Promise<KPuzzle> {\n  const pgPromise = descAsyncGetPuzzleGeometry(desc, options);\n  return asyncGetKPuzzle(pgPromise, `description: ${desc}`);\n}\n\n// TODO: Can we avoid relying on IDs to deduplicate work at higher levels?\nlet nextCustomID = 1;\n\nexport function customPGPuzzleLoader(\n  desc: PuzzleDescriptionString,\n  info?: {\n    fullName?: string;\n    inventedBy?: string[];\n    inventionYear?: number;\n  },\n): PuzzleLoader {\n  const customID = nextCustomID++;\n  let cachedKPuzzle: Promise<KPuzzle> | null = null;\n  const kpuzzlePromiseFn = async () => {\n    return (cachedKPuzzle ??= asyncGetKPuzzleByDesc(desc));\n  };\n  const puzzleLoader: PuzzleLoader = {\n    id: `custom-${customID}`,\n    fullName: info?.fullName ?? `Custom Puzzle (instance #${customID})`,\n    kpuzzle: kpuzzlePromiseFn,\n    svg: async () => {\n      const pg = await descAsyncGetPuzzleGeometry(desc);\n      return pg.generatesvg();\n    },\n    pg: async () => {\n      return descAsyncGetPuzzleGeometry(desc);\n    },\n    basePG: async () => {\n      return descAsyncGetPuzzleGeometry(desc, {\n        allMoves: false,\n        orientCenters: false,\n        addRotations: false,\n      });\n    },\n    puzzleSpecificSimplifyOptionsPromise:\n      puzzleSpecificSimplifyOptionsPromise(kpuzzlePromiseFn),\n  };\n  if (info?.inventedBy) {\n    puzzleLoader.inventedBy = info.inventedBy;\n  }\n  if (info?.inventionYear) {\n    puzzleLoader.inventionYear = info.inventionYear;\n  }\n  return puzzleLoader;\n}\n", "import { Alg } from \"../../../../alg\";\nimport type { KPattern, KPuzzle, KTransformation } from \"../../../../kpuzzle\";\n\nexport function puzzleOrientation2x2x2Idx(pattern: KPattern): number {\n  const inverse = pattern.experimentalToTransformation()!.invert();\n\n  const inverseDFL = inverse.transformationData[\"CORNERS\"];\n  return inverseDFL.permutation[6] * 3 + inverseDFL.orientationDelta[6];\n}\n\nconst puzzleOrientationCacheRaw: {\n  transformation: KTransformation;\n  alg: Alg;\n}[] = new Array<KTransformation>(24) as any;\n\nconst puzzleOrientationCacheInitialized = false;\n// We rely on the (first) caller to pass in the `KPuzzle`, so that we don't need to get our own synchronous reference.\nexport function puzzleOrientation2x2x2Cache(\n  kpuzzle: KPuzzle,\n): typeof puzzleOrientationCacheRaw {\n  if (!puzzleOrientationCacheInitialized) {\n    {\n      const uAlgs: Alg[] = [\"\", \"z\", \"x\", \"z'\", \"x'\", \"x2\"].map((s) =>\n        Alg.fromString(s),\n      );\n      const yAlg = new Alg(\"y\");\n      for (const uAlg of uAlgs) {\n        let transformation = kpuzzle.algToTransformation(uAlg);\n        for (let i = 0; i < 4; i++) {\n          transformation = transformation.applyAlg(yAlg);\n          const idx = puzzleOrientation2x2x2Idx(transformation.toKPattern());\n          puzzleOrientationCacheRaw[idx] = {\n            transformation: transformation.invert(),\n            alg: uAlg.concat(yAlg),\n          };\n        }\n      }\n    }\n  }\n  return puzzleOrientationCacheRaw;\n}\n\nexport function normalize2x2x2Orientation(pattern: KPattern): {\n  normalizedPattern: KPattern;\n  normalizationAlg: Alg;\n} {\n  const idx = puzzleOrientation2x2x2Idx(pattern);\n  const { transformation, alg } = puzzleOrientation2x2x2Cache(pattern.kpuzzle)[\n    idx\n  ];\n  return {\n    normalizedPattern: pattern.applyTransformation(transformation),\n    normalizationAlg: alg.invert(),\n  };\n}\n\n// The `options` argument is required for now, because we haven't yet come up\n// with a general way to specify different kinds of solved for the same puzle.\nexport function experimentalIs2x2x2Solved(\n  pattern: KPattern,\n  options: {\n    ignorePuzzleOrientation: boolean;\n  },\n): boolean {\n  if (options.ignorePuzzleOrientation) {\n    pattern = normalize2x2x2Orientation(pattern).normalizedPattern;\n  }\n  return !!pattern.experimentalToTransformation()!.isIdentityTransformation(); // TODO: Compare to start pattern instead?\n}\n", "import { KPuzzle } from \"../../kpuzzle\";\nimport { getCached } from \"../async/lazy-cached\";\nimport { cube3x3x3KPuzzleDefinition as experimentalCube3x3x3KPuzzleDefinition } from \"../implementations/dynamic/3x3x3/3x3x3.kpuzzle.json\";\nimport { experimentalIs3x3x3Solved } from \"../implementations/dynamic/3x3x3/puzzle-orientation\";\n\nexport {\n  type AlgTransformData,\n  getPartialAppendOptionsForPuzzleSpecificSimplifyOptions,\n} from \"../PuzzleLoader\";\nexport { transformAlg } from \"../transformAlg\";\nexport { experimentalCube3x3x3KPuzzleDefinition };\n\n/** @deprecated */\nexport const experimental3x3x3KPuzzle = new KPuzzle(\n  experimentalCube3x3x3KPuzzleDefinition,\n);\nexperimentalCube3x3x3KPuzzleDefinition.experimentalIsPatternSolved =\n  experimentalIs3x3x3Solved;\n\nexport { customPGPuzzleLoader as experimentalCustomPGPuzzleLoader } from \"../customPGPuzzleLoader\";\nexport {\n  experimentalIs2x2x2Solved,\n  normalize2x2x2Orientation as experimentalNormalize2x2x2Orientation,\n  puzzleOrientation2x2x2Cache as experimentalPuzzleOrientation2x2x2Cache,\n  puzzleOrientation2x2x2Idx as experimentalPuzzleOrientation2x2x2Idx,\n} from \"../implementations/dynamic/2x2x2/puzzle-orientation\"; // TODO: Actually dynamic\nexport {\n  experimentalIs3x3x3Solved,\n  normalize3x3x3Orientation as experimentalNormalize3x3x3Orientation,\n  puzzleOrientation3x3x3Cache as experimentalPuzzleOrientation3x3x3Cache,\n  puzzleOrientation3x3x3Idx as experimentalPuzzleOrientation3x3x3Idx,\n} from \"../implementations/dynamic/3x3x3/puzzle-orientation\"; // TODO: Actually dynamic\nexport type { KeyMapping } from \"../PuzzleLoader\";\nexport type {\n  FaceletMeshStickeringMask as ExperimentalFaceletMeshStickeringMask,\n  PieceStickeringMask as ExperimentalPieceStickeringMask,\n  StickeringMask as ExperimentalStickeringMask,\n} from \"../stickerings/mask\";\nexport {\n  getFaceletStickeringMask as experimentalGetFaceletStickeringMask,\n  getPieceStickeringMask as experimentalGetPieceStickeringMask,\n  PieceStickering as ExperimentalPieceStickering,\n} from \"../stickerings/mask\";\nexport { experimentalStickerings } from \"../stickerings/puzzle-stickerings\";\nexport const bigCubePuzzleOrientation = getCached(\n  () => import(\"../implementations/dynamic/big-cubes/big-puzzle-orientation\"),\n);\n", "import { type AlgLeaf, Move, Pause } from \"../../../alg\";\n\n// See: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code\n\nexport const cube3x3x3KeyMapping: { [key: number | string]: AlgLeaf } = {\n  KeyI: new Move(\"R\"),\n  KeyK: new Move(\"R'\"),\n  KeyW: new Move(\"B\"),\n  KeyO: new Move(\"B'\"),\n  KeyS: new Move(\"D\"),\n  KeyL: new Move(\"D'\"),\n  KeyD: new Move(\"L\"),\n  KeyE: new Move(\"L'\"),\n  KeyJ: new Move(\"U\"),\n  KeyF: new Move(\"U'\"),\n  KeyH: new Move(\"F\"),\n  KeyG: new Move(\"F'\"),\n\n  KeyC: new Move(\"l\"),\n  KeyR: new Move(\"l'\"),\n  KeyU: new Move(\"r\"),\n  KeyM: new Move(\"r'\"),\n\n  KeyX: new Move(\"d\"),\n  Comma: new Move(\"d'\"),\n\n  KeyT: new Move(\"x\"),\n  KeyY: new Move(\"x\"),\n  KeyV: new Move(\"x'\"),\n  KeyN: new Move(\"x'\"),\n  Semicolon: new Move(\"y\"),\n  KeyA: new Move(\"y'\"),\n  KeyP: new Move(\"z\"),\n  KeyQ: new Move(\"z'\"),\n\n  KeyZ: new Move(\"M'\"),\n  KeyB: new Move(\"M\"),\n  Period: new Move(\"M'\"),\n\n  Backquote: new Pause(),\n};\n", "import type { PuzzleSpecificSimplifyOptions } from \"../../../alg\";\nimport { Move, QuantumMove } from \"../../../alg\";\n\nenum Axis {\n  X = \"x axis\",\n  Y = \"y axis\",\n  Z = \"z axis\",\n}\n\nenum MoveSourceType {\n  INDEXABLE_SLICE_NEAR,\n  INDEXABLE_SLICE_FAR,\n  INDEXABLE_WIDE_NEAR,\n  INDEXABLE_WIDE_FAR,\n  SPECIFIC_SLICE,\n  ROTATION,\n}\n\ninterface MoveSourceInfo {\n  family: string;\n  direction: -1 | 1;\n  type: MoveSourceType;\n  from: number;\n  to: number;\n}\n\nfunction makeSourceInfo(\n  moveStrings: string[],\n  type: MoveSourceType,\n  from: number,\n  to: number,\n): MoveSourceInfo[] {\n  const output: MoveSourceInfo[] = [];\n  for (const moveString of moveStrings) {\n    const move = Move.fromString(moveString);\n    const { family, amount: direction } = move;\n    if (![-1, 1].includes(direction)) {\n      // TODO: test iner/outer\n      // TODO: Can we move this to a test file?\n      throw new Error(\"Invalid config move\");\n    }\n    output.push({ family, direction: direction as -1 | 1, type, from, to });\n  }\n  return output;\n}\n\ninterface AxisInfo {\n  sliceDiameter: number;\n  extendsThroughEntirePuzzle: boolean;\n  moveSourceInfos: MoveSourceInfo[];\n}\n\n// TODO: wide slices\nconst axisInfos: Record<Axis, AxisInfo> = {\n  [Axis.X]: {\n    sliceDiameter: 3,\n    extendsThroughEntirePuzzle: true,\n    moveSourceInfos: [\n      ...makeSourceInfo([\"R\"], MoveSourceType.INDEXABLE_SLICE_NEAR, 0, 3),\n      ...makeSourceInfo([\"L'\"], MoveSourceType.INDEXABLE_SLICE_FAR, 0, 3),\n      ...makeSourceInfo([\"r\", \"Rw\"], MoveSourceType.INDEXABLE_WIDE_NEAR, 0, 2),\n      ...makeSourceInfo([\"l'\", \"Lw'\"], MoveSourceType.INDEXABLE_WIDE_FAR, 0, 2),\n      ...makeSourceInfo([\"M'\"], MoveSourceType.SPECIFIC_SLICE, 1, 2), // TODO: remove some indices?\n      ...makeSourceInfo([\"x\", \"Uv\", \"Dv'\"], MoveSourceType.ROTATION, 0, 3), // TODO: remove some indices?\n    ],\n  },\n  [Axis.Y]: {\n    sliceDiameter: 3,\n    extendsThroughEntirePuzzle: true,\n    moveSourceInfos: [\n      ...makeSourceInfo([\"U\"], MoveSourceType.INDEXABLE_SLICE_NEAR, 0, 3),\n      ...makeSourceInfo([\"D'\"], MoveSourceType.INDEXABLE_SLICE_FAR, 0, 3),\n      ...makeSourceInfo([\"u\", \"Uw\"], MoveSourceType.INDEXABLE_WIDE_NEAR, 0, 2),\n      ...makeSourceInfo([\"d'\", \"Dw'\"], MoveSourceType.INDEXABLE_WIDE_FAR, 0, 2),\n      ...makeSourceInfo([\"E'\"], MoveSourceType.SPECIFIC_SLICE, 1, 2), // TODO: remove some indices?\n      ...makeSourceInfo([\"y\", \"Uv\", \"Dv'\"], MoveSourceType.ROTATION, 0, 3), // TODO: remove some indices?\n    ],\n  },\n  [Axis.Z]: {\n    sliceDiameter: 3,\n    extendsThroughEntirePuzzle: true,\n    moveSourceInfos: [\n      ...makeSourceInfo([\"F\"], MoveSourceType.INDEXABLE_SLICE_NEAR, 0, 3),\n      ...makeSourceInfo([\"B'\"], MoveSourceType.INDEXABLE_SLICE_FAR, 0, 3),\n      ...makeSourceInfo([\"f\", \"Fw\"], MoveSourceType.INDEXABLE_WIDE_NEAR, 0, 3),\n      ...makeSourceInfo([\"b'\", \"Bw'\"], MoveSourceType.INDEXABLE_WIDE_FAR, 0, 3),\n      ...makeSourceInfo([\"S\"], MoveSourceType.SPECIFIC_SLICE, 1, 2), // TODO: remove some indices?\n      ...makeSourceInfo([\"z\", \"Fv\", \"Bv'\"], MoveSourceType.ROTATION, 0, 3), // TODO: remove some indices?\n    ],\n  },\n};\n\nconst byFamily: Record<string, { axis: Axis; moveSourceInfo: MoveSourceInfo }> =\n  {};\nfor (const [axis, info] of Object.entries(axisInfos)) {\n  for (const moveSourceInfo of info.moveSourceInfos) {\n    byFamily[moveSourceInfo.family] = { axis: axis as Axis, moveSourceInfo };\n  }\n}\n\n// TODO: lazy initialization?\nconst byAxisThenType: Record<\n  Axis,\n  Partial<Record<MoveSourceType, MoveSourceInfo[]>>\n> = {} as any; // TODO: avoid typecast (using `Object.fromEntries`?)\nfor (const axis of Object.keys(axisInfos) as Axis[]) {\n  const entry: Partial<Record<MoveSourceType, MoveSourceInfo[]>> = {};\n  byAxisThenType[axis] = entry;\n  for (const moveSourceInfo of axisInfos[axis].moveSourceInfos) {\n    (entry[moveSourceInfo.type] ??= []).push(moveSourceInfo);\n  }\n}\n\n// TODO: consolidate lookup tables?\nconst byAxisThenSpecificSlices: Record<\n  Axis,\n  Map<number, MoveSourceInfo>\n> = {} as any; // TODO: avoid typecast (using `Object.fromEntries`?)\nfor (const axis of Object.keys(axisInfos) as Axis[]) {\n  const entry: Map<number, MoveSourceInfo> = new Map();\n  byAxisThenSpecificSlices[axis] = entry;\n  for (const moveSourceInfo of axisInfos[axis].moveSourceInfos) {\n    // We only want to use the first entry per slice index (in the unlikely case there are multiple).\n    if (!entry.get(moveSourceInfo.from)) {\n      entry.set(moveSourceInfo.from, moveSourceInfo);\n    }\n  }\n}\n\nfunction firstOfType(\n  axis: Axis,\n  moveSourceType: MoveSourceType,\n): MoveSourceInfo {\n  const entry = byAxisThenType[axis][moveSourceType]?.[0];\n  if (!entry) {\n    throw new Error(\n      `Could not find a reference move (axis: ${axis}, move source type: ${moveSourceType})`,\n    );\n  }\n  return entry;\n}\n\nconst areQuantumMovesSameAxis = (\n  quantumMove1: QuantumMove,\n  quantumMove2: QuantumMove,\n) => {\n  return (\n    byFamily[quantumMove1.family].axis === byFamily[quantumMove2.family].axis\n  );\n};\n\nfunction simplestMove(\n  axis: Axis,\n  from: number,\n  to: number,\n  directedAmount: number,\n): Move {\n  if (from + 1 === to) {\n    const sliceSpecificInfo = byAxisThenSpecificSlices[axis].get(from);\n    if (sliceSpecificInfo) {\n      return new Move(\n        new QuantumMove(sliceSpecificInfo.family),\n        directedAmount * sliceSpecificInfo.direction,\n      );\n    }\n  }\n\n  const axisInfo = axisInfos[axis];\n  const { sliceDiameter } = axisInfo;\n  if (from === 0 && to === sliceDiameter) {\n    const moveSourceInfo = firstOfType(axis, MoveSourceType.ROTATION);\n    return new Move(\n      new QuantumMove(moveSourceInfo.family),\n      directedAmount * moveSourceInfo.direction,\n    );\n  }\n\n  // const specificSliceInfo = byAxisThenSpecificSlices[axis].get(from);\n  const far = from + to > sliceDiameter; // (from + to) / 2 > sliceDiameter / 2\n  if (far) {\n    [from, to] = [sliceDiameter - to, sliceDiameter - from];\n  }\n\n  let outerLayer: number | null = from + 1; // change to 1-indexed\n  let innerLayer: number | null = to; // already 1-indexed\n  const slice = outerLayer === innerLayer;\n  if (slice) {\n    innerLayer = null;\n  }\n\n  if (outerLayer === 1) {\n    outerLayer = null;\n  }\n  if (slice && outerLayer === 1) {\n    innerLayer = null;\n  }\n  if (!slice && innerLayer === 2) {\n    innerLayer = null;\n  }\n\n  const moveSourceType = slice\n    ? far\n      ? MoveSourceType.INDEXABLE_SLICE_FAR\n      : MoveSourceType.INDEXABLE_SLICE_NEAR\n    : far\n      ? MoveSourceType.INDEXABLE_WIDE_FAR\n      : MoveSourceType.INDEXABLE_WIDE_NEAR;\n  const moveSourceInfo = firstOfType(axis, moveSourceType);\n  return new Move(\n    new QuantumMove(moveSourceInfo.family, innerLayer, outerLayer),\n    directedAmount * moveSourceInfo.direction,\n  );\n}\n\nfunction simplifySameAxisMoves(\n  moves: Move[],\n  quantumMod: boolean = true, // TODO\n): Move[] {\n  if (moves.length === 0) {\n    // TODO: can we use the type system to avoid this?\n    return [];\n  }\n\n  const axis: Axis = byFamily[moves[0].family].axis;\n  const axisInfo = axisInfos[axis];\n  const { sliceDiameter } = axisInfo;\n  const sliceDeltas = new Map<number, number>();\n  let lastCandidateRange: {\n    suffixLength: number;\n    sliceDeltas: Map<number, number>;\n  } | null = null;\n\n  function adjustValue(idx: number, relativeDelta: number) {\n    let newDelta = (sliceDeltas.get(idx) ?? 0) + relativeDelta;\n    if (quantumMod) {\n      newDelta = (newDelta % 4) + (5 % 4) - 1; // TODO: Use a passed-in `modMove`?\n    }\n    if (newDelta === 0) {\n      sliceDeltas.delete(idx);\n    } else {\n      sliceDeltas.set(idx, newDelta);\n    }\n  }\n  // TODO: go as far as possible instead of trying to take all moves, e.g. simplify U y y' to U.\n  let suffixLength = 0;\n  // TODO: Reverse iterator?\n  for (const move of Array.from(moves).reverse()) {\n    suffixLength++;\n    const { moveSourceInfo } = byFamily[move.family];\n    const directedAmount = move.amount * moveSourceInfo.direction;\n    // console.log({ directedAmount });\n    switch (moveSourceInfo.type) {\n      case MoveSourceType.INDEXABLE_SLICE_NEAR: {\n        // We convert to zero-indexing\n        const idx = (move.innerLayer ?? 1) - 1;\n        adjustValue(idx, directedAmount);\n        adjustValue(idx + 1, -directedAmount);\n        break;\n      }\n      case MoveSourceType.INDEXABLE_SLICE_FAR: {\n        // We convert to zero-indexing (which cancels with the subtraction from the slice width)\n        const idx = sliceDiameter - (move.innerLayer ?? 1);\n        adjustValue(idx, directedAmount);\n        adjustValue(idx + 1, -directedAmount);\n        break;\n      }\n      case MoveSourceType.INDEXABLE_WIDE_NEAR: {\n        adjustValue((move.outerLayer ?? 1) - 1, directedAmount);\n        adjustValue(move.innerLayer ?? 2, -directedAmount);\n        break;\n      }\n      case MoveSourceType.INDEXABLE_WIDE_FAR: {\n        adjustValue(sliceDiameter - (move.innerLayer ?? 2), directedAmount);\n        adjustValue(\n          sliceDiameter - ((move.outerLayer ?? 1) - 1),\n          -directedAmount,\n        );\n        break;\n      }\n      case MoveSourceType.SPECIFIC_SLICE: {\n        // We convert to zero-indexing (which cancels with the subtraction from the slice width)\n        adjustValue(moveSourceInfo.from, directedAmount);\n        adjustValue(moveSourceInfo.to, -directedAmount);\n        break;\n      }\n      case MoveSourceType.ROTATION: {\n        adjustValue(0, directedAmount);\n        adjustValue(sliceDiameter, -directedAmount);\n        break;\n      }\n    }\n    if ([0, 2].includes(sliceDeltas.size)) {\n      lastCandidateRange = { suffixLength, sliceDeltas: new Map(sliceDeltas) };\n    }\n  }\n  if (sliceDeltas.size === 0) {\n    return [];\n  }\n  // TODO: handle this check in the destructuring assignment?\n  if (!lastCandidateRange) {\n    return moves;\n  }\n  let [from, to] = lastCandidateRange.sliceDeltas.keys();\n  if (from > to) {\n    [from, to] = [to, from];\n  }\n  const directedAmount = lastCandidateRange.sliceDeltas.get(from)!;\n  // TODO: Handle empty move\n  return [\n    ...moves.slice(0, -lastCandidateRange.suffixLength),\n    ...(directedAmount !== 0\n      ? [simplestMove(axis, from, to, directedAmount)]\n      : []),\n  ];\n}\n\nexport const puzzleSpecificSimplifyOptions333: PuzzleSpecificSimplifyOptions = {\n  quantumMoveOrder: () => 4,\n  // doQuantumMovesCommute: areQuantumMovesSameAxis,\n  axis: { areQuantumMovesSameAxis, simplifySameAxisMoves },\n};\n", "// Include 3x3x3 in the main bundle for better performance.\nimport type { ExperimentalStickering } from \"../../../twisty\";\nimport { asyncGetPuzzleGeometry } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport { experimental3x3x3KPuzzle } from \"../../cubing-private\";\nimport type { AlgTransformData, PuzzleLoader } from \"../../PuzzleLoader\";\nimport {\n  cubeLikeStickeringList,\n  cubeLikeStickeringMask,\n} from \"../../stickerings/cube-like-stickerings\";\nimport type { StickeringMask } from \"../../stickerings/mask\";\nimport { cube3x3x3KeyMapping } from \"./cube3x3x3KeyMapping\";\nimport { puzzleSpecificSimplifyOptions333 } from \"./puzzle-specific-simplifications\";\n\nexport const cubeMirrorTransforms: AlgTransformData = {\n  \"\u2194 Mirror (M)\": {\n    replaceMovesByFamily: {\n      L: \"R\",\n      R: \"L\",\n      l: \"r\",\n      r: \"l\",\n      Lw: \"Rw\",\n      Rw: \"Lw\",\n      Lv: \"Rv\",\n      Rv: \"Lv\",\n    },\n    invertExceptByFamily: new Set([\"x\", \"M\", \"m\"]),\n  },\n  \"\u2922 Mirror (S)\": {\n    replaceMovesByFamily: {\n      F: \"B\",\n      B: \"F\",\n      f: \"b\",\n      b: \"f\",\n      Fw: \"Bw\",\n      Bw: \"Fw\",\n      Fv: \"Bv\",\n      Bv: \"Fv\",\n    },\n    invertExceptByFamily: new Set([\"z\", \"S\", \"s\"]),\n  },\n  \"\u2195 Mirror (E)\": {\n    replaceMovesByFamily: {\n      U: \"D\",\n      D: \"U\",\n      u: \"d\",\n      d: \"u\",\n      Uw: \"Dw\",\n      Dw: \"Uw\",\n      Uv: \"Dv\",\n      Dv: \"Uv\",\n    },\n    invertExceptByFamily: new Set([\"y\", \"E\", \"e\"]),\n  },\n};\n\n/** @category Specific Puzzles */\nexport const cube3x3x3 = {\n  id: \"3x3x3\",\n  fullName: \"3\u00D73\u00D73 Cube\",\n  inventedBy: [\"Ern\u0151 Rubik\"],\n  inventionYear: 1974, // https://en.wikipedia.org/wiki/Rubik%27s_Cube#Conception_and_development\n  kpuzzle: getCached(async () => {\n    return experimental3x3x3KPuzzle;\n  }),\n  svg: getCached(async () => {\n    return (await import(\"../dynamic/3x3x3/puzzles-dynamic-3x3x3\"))\n      .cube3x3x3SVG;\n  }),\n  llSVG: getCached(async () => {\n    return (await import(\"../dynamic/3x3x3/puzzles-dynamic-3x3x3\"))\n      .cube3x3x3LLSVG;\n  }),\n  llFaceSVG: getCached(async () => {\n    return (await import(\"../dynamic/3x3x3/puzzles-dynamic-3x3x3\"))\n      .cube3x3x3LLFaceSVG;\n  }),\n  pg: getCached(async () => {\n    return asyncGetPuzzleGeometry(\"3x3x3\");\n  }),\n  stickeringMask: (\n    stickering: ExperimentalStickering,\n  ): Promise<StickeringMask> => cubeLikeStickeringMask(cube3x3x3, stickering),\n  stickerings: () => cubeLikeStickeringList(\"3x3x3\"),\n  puzzleSpecificSimplifyOptions: puzzleSpecificSimplifyOptions333,\n  keyMapping: async () => cube3x3x3KeyMapping, // TODO: async loading\n  algTransformData: cubeMirrorTransforms,\n} satisfies PuzzleLoader;\n"],
  "mappings": "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",
  "names": ["pieceStickerings", "LL", "puzzleOrientationCacheRaw", "puzzleOrientationCacheInitialized", "from", "moveSourceInfo", "directedAmount"]
}
