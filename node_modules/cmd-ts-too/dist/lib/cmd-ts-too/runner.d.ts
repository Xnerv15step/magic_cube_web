import { type Result } from "./Result";
import type { ArgParser, ParseContext, ParsingResult, Register } from "./argparser";
import { Exit } from "./effects";
import type { PrintHelp, Versioned } from "./helpdoc";
export type Handling<Values, Result> = {
    handler: (values: Values) => Result;
};
export type Runner<HandlerArgs, HandlerResult> = PrintHelp & Partial<Versioned> & Register & Handling<HandlerArgs, HandlerResult> & ArgParser<HandlerArgs> & {
    run(context: ParseContext): Promise<ParsingResult<HandlerResult>>;
};
export type Into<R extends Runner<any, any>> = R extends Runner<any, infer X> ? X : never;
export declare function run<R extends Runner<any, any>>(ap: R, strings: string[]): Promise<Into<R>>;
/**
 * Runs a command but does not apply any effect
 */
export declare function runSafely<R extends Runner<any, any>>(ap: R, strings: string[]): Promise<Result<Exit, Into<R>>>;
/**
 * Run a command but don't quit. Returns an `Result` instead.
 */
export declare function dryRun<R extends Runner<any, any>>(ap: R, strings: string[]): Promise<Result<string, Into<R>>>;
/**
 * Parse the command as if to run it, but only return the parse result and don't run the command.
 */
export declare function parse<R extends Runner<any, any>>(ap: R, strings: string[]): Promise<ParsingResult<any>>;
