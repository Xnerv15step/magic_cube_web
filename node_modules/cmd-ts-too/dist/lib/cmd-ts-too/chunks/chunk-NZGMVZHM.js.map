{
  "version": 3,
  "sources": ["../../../../src/subcommands.ts", "../../../../src/Result.ts", "../../../../src/effects.ts", "../../../../src/flag.ts", "../../../../src/newparser/findOption.ts", "../../../../src/from.ts", "../../../../src/type.ts", "../../../../src/types.ts", "../../../../src/circuitbreaker.ts", "../../../../src/positional.ts", "../../../../src/binary.ts", "../../../../src/command.ts", "../../../../src/utils.ts", "../../../../src/option.ts", "../../../../src/errorBox.ts", "../../../../src/newparser/parser.ts", "../../../../src/newparser/tokenizer.ts", "../../../../src/runner.ts", "../../../../src/restPositionals.ts", "../../../../src/multiflag.ts", "../../../../src/multioption.ts", "../../../../src/union.ts", "../../../../src/oneOf.ts", "../../../../src/rest.ts"],
  "sourcesContent": ["import chalk from \"chalk\";\nimport didYouMean from \"didyoumean\";\nimport * as Result from \"./Result\";\n// import { Runner, Into } from './runner';\nimport type {\n  ArgParser,\n  ParseContext,\n  ParsingInto,\n  ParsingResult,\n} from \"./argparser\";\nimport { createCircuitBreaker, handleCircuitBreaker } from \"./circuitbreaker\";\nimport type { From } from \"./from\";\nimport type { Aliased, Descriptive, Named, Versioned } from \"./helpdoc\";\nimport { positional } from \"./positional\";\nimport type { Runner } from \"./runner\";\n\ntype Output<\n  Commands extends Record<string, ArgParser<any> & Runner<any, any>>,\n> = {\n  [key in keyof Commands]: { command: key; args: ParsingInto<Commands[key]> };\n}[keyof Commands];\n\ntype RunnerOutput<\n  Commands extends Record<string, Runner<any, any> & ArgParser<any>>,\n> = {\n  [key in keyof Commands]: {\n    command: key;\n    value: Commands[key] extends Runner<any, infer X> ? X : never;\n  };\n}[keyof Commands];\n\n/**\n * Combine multiple `command`s into one\n */\nexport function subcommands<\n  Commands extends Record<\n    string,\n    ArgParser<any> & Runner<any, any> & Partial<Descriptive & Aliased>\n  >,\n>(config: {\n  name: string;\n  version?: string;\n  cmds: Commands;\n  description?: string;\n}): ArgParser<Output<Commands>> &\n  Named &\n  Partial<Descriptive & Versioned> &\n  Runner<Output<Commands>, RunnerOutput<Commands>> {\n  const circuitbreaker = createCircuitBreaker(!!config.version);\n  const type: From<string, keyof Commands> = {\n    async from(str) {\n      const commands = Object.entries(config.cmds).map(([name, cmd]) => {\n        return {\n          cmdName: name as keyof Commands,\n          names: [name, ...(cmd.aliases ?? [])],\n        };\n      });\n      const cmd = commands.find((x) => x.names.includes(str));\n      if (cmd) {\n        return cmd.cmdName;\n      }\n      let errorMessage = \"Not a valid subcommand name\";\n\n      const closeOptions = didYouMean(\n        str,\n        flatMap(commands, (x) => x.names),\n      );\n      if (closeOptions) {\n        const option = Array.isArray(closeOptions)\n          ? closeOptions[0]\n          : closeOptions;\n        errorMessage += `\\nDid you mean ${chalk.italic(option)}?`;\n      }\n\n      throw new Error(errorMessage);\n    },\n  };\n\n  const subcommand = positional({\n    displayName: \"subcommand\",\n    description: `one of ${Object.keys(config.cmds).join(\", \")}`,\n    type,\n  });\n\n  function normalizeContext(context: ParseContext) {\n    if (context.hotPath?.length === 0) {\n      context.hotPath.push(config.name);\n    }\n\n    // Called without any arguments? We default to subcommand help.\n    if (!context.nodes.some((n) => !context.visitedNodes.has(n))) {\n      context.autoFallbackHelpTriggered = true;\n      context.nodes.push({\n        type: \"longOption\",\n        index: 0,\n        key: \"help\",\n        raw: \"--help\",\n      });\n    }\n  }\n\n  return {\n    version: config.version,\n    description: config.description,\n    name: config.name,\n    handler: (value) => {\n      const cmd = config.cmds[value.command];\n      return cmd.handler(value.args);\n    },\n    register(opts) {\n      for (const cmd of Object.values(config.cmds)) {\n        cmd.register(opts);\n      }\n      circuitbreaker.register(opts);\n    },\n    printHelp(context) {\n      const lines: string[] = [];\n      const argsSoFar = context.hotPath?.join(\" \") ?? \"cli\";\n\n      lines.push(chalk.bold(argsSoFar + chalk.italic(\" <subcommand>\")));\n\n      if (config.description) {\n        lines.push(chalk.dim(\"> \") + config.description);\n      }\n\n      lines.push(\"\");\n      lines.push(`where ${chalk.italic(\"<subcommand>\")} can be one of:`);\n      lines.push(\"\");\n\n      for (const key of Object.keys(config.cmds)) {\n        const cmd = config.cmds[key];\n        let description = cmd.description ?? \"\";\n        description = description && ` - ${description} `;\n        if (cmd.aliases?.length) {\n          const aliasTxt = cmd.aliases.length === 1 ? \"alias\" : \"aliases\";\n          const aliases = cmd.aliases.join(\", \");\n          description += chalk.dim(`[${aliasTxt}: ${aliases}]`);\n        }\n        const row = chalk.dim(\"- \") + key + description;\n        lines.push(row.trim());\n      }\n\n      const helpCommand = chalk.yellow(`${argsSoFar} <subcommand> --help`);\n\n      lines.push(\"\");\n      lines.push(chalk.dim(`For more help, try running \\`${helpCommand}\\``));\n      return lines.join(\"\\n\");\n    },\n    async parse(\n      context: ParseContext,\n    ): Promise<ParsingResult<Output<Commands>>> {\n      normalizeContext(context);\n      const parsed = await subcommand.parse(context);\n\n      if (Result.isErr(parsed)) {\n        return Result.err({\n          errors: parsed.error.errors,\n          partialValue: {},\n        });\n      }\n\n      context.hotPath?.push(parsed.value as string);\n\n      const cmd = config.cmds[parsed.value];\n      const parsedCommand = await cmd.parse(context);\n      if (Result.isErr(parsedCommand)) {\n        return Result.err({\n          errors: parsedCommand.error.errors,\n          partialValue: {\n            command: parsed.value,\n            args: parsedCommand.error.partialValue,\n          },\n        });\n      }\n      return Result.ok({\n        args: parsedCommand.value,\n        command: parsed.value,\n      });\n    },\n    async run(context): Promise<ParsingResult<RunnerOutput<Commands>>> {\n      normalizeContext(context);\n      const parsedSubcommand = await subcommand.parse(context);\n\n      if (Result.isErr(parsedSubcommand)) {\n        const breaker = await circuitbreaker.parse(context);\n        handleCircuitBreaker(context, this, breaker);\n\n        return Result.err({ ...parsedSubcommand.error, partialValue: {} });\n      }\n\n      context.hotPath?.push(parsedSubcommand.value as string);\n\n      const cmd = config.cmds[parsedSubcommand.value];\n      const commandRun = await cmd.run(context);\n\n      if (Result.isOk(commandRun)) {\n        return Result.ok({\n          command: parsedSubcommand.value,\n          value: commandRun.value,\n        });\n      }\n\n      return Result.err({\n        ...commandRun.error,\n        partialValue: {\n          command: parsedSubcommand.value,\n          value: commandRun.error.partialValue,\n        },\n      });\n    },\n  };\n}\n\nfunction flatMap<T, R>(array: T[], f: (t: T) => R[]): R[] {\n  const rs: R[] = [];\n  for (const item of array) {\n    rs.push(...f(item));\n  }\n  return rs;\n}\n", "/**\n * A successful value\n */\nexport type Ok<R> = { _tag: \"ok\"; value: R };\n\n/**\n * A failed value\n */\nexport type Err<L> = { _tag: \"error\"; error: L };\n\n/**\n * A safe result type: imagine a language with no exceptions \u2014 the way to handle\n * errors would be to use something like a tagged union type.\n *\n * Why would we want that? I want to explicitly handle exceptions in this library\n * and having this construct really helps. It's also pretty easy to implement.\n */\nexport type Result<L, R> = Err<L> | Ok<R>;\n\nexport function ok<O>(value: O): Ok<O> {\n  return { _tag: \"ok\", value };\n}\n\nexport function err<E>(error: E): Err<E> {\n  return { _tag: \"error\", error };\n}\n\n/**\n * Checks whether a value is an `Ok`.\n * Handy with TypeScript guards\n */\nexport function isOk<R>(result: Result<any, R>): result is Ok<R> {\n  return result._tag === \"ok\";\n}\n\n/**\n * Checks whether a value is an `Err`.\n * Handy with TypeScript guards\n */\nexport function isErr<L>(either: Result<L, any>): either is Err<L> {\n  return either._tag === \"error\";\n}\n\n/**\n * Convert a `Promise<T>` into a `Promise<Result<Error, T>>`,\n * therefore catching the errors and being able to handle them explicitly\n */\nexport async function safeAsync<O>(\n  promise: Promise<O>,\n): Promise<Result<Error, O>> {\n  try {\n    const value = await promise;\n    return ok(value);\n  } catch (e: any) {\n    return err(e);\n  }\n}\n", "/**\n * \"Effects\" are custom exceptions that can do stuff.\n * The concept comes from React, where they throw a `Promise` to provide the ability to write\n * async code with synchronous syntax.\n *\n * These effects _should stay an implementation detail_ and not leak out of the library.\n *\n * @packageDocumentation\n */\n\nimport chalk from \"chalk\";\n\n/**\n * An effect to exit the program with a message\n *\n * **Why this is an effect?**\n *\n * Using `process.exit` in a program is both a problem:\n * * in tests, because it needs to be mocked somehow\n * * in browser usage, because it does not have `process` at all\n *\n * Also, using `console.log` is something we'd rather avoid and return strings, and if returning strings\n * would be harmful for performance we might ask for a stream to write to:\n * Printing to stdout and stderr means that we don't control the values and it ties us to only use `cmd-ts`\n * with a command line, and again, to mock `stdout` and `stderr` it if we want to test it.\n */\nexport class Exit {\n  constructor(\n    public readonly config: {\n      exitCode: number;\n      message: string;\n      into: \"stdout\" | \"stderr\";\n    },\n  ) {}\n\n  run(): never {\n    const output = this.output();\n    output(this.config.message);\n    process.exit(this.config.exitCode);\n  }\n\n  dryRun(): string {\n    const { into, message, exitCode } = this.config;\n    const coloredExit = chalk.dim(\n      `process exited with status ${exitCode} (${into})`,\n    );\n    return `${message}\\n\\n${coloredExit}`;\n  }\n\n  private output() {\n    if (this.config.into === \"stderr\") {\n      return console.error;\n    }\n    return console.log;\n  }\n}\n", "import chalk from \"chalk\";\nimport * as Result from \"./Result\";\nimport type {\n  ArgParser,\n  ParseContext,\n  ParsingResult,\n  Register,\n} from \"./argparser\";\nimport type { Default } from \"./default\";\nimport type {\n  Descriptive,\n  EnvDoc,\n  LongDoc,\n  ProvidesHelp,\n  ShortDoc,\n} from \"./helpdoc\";\nimport { findOption } from \"./newparser/findOption\";\nimport { type HasType, type OutputOf, type Type, extendType } from \"./type\";\nimport { boolean as booleanIdentity } from \"./types\";\nimport type { AllOrNothing } from \"./utils\";\n\ntype FlagConfig<Decoder extends Type<boolean, any>> = LongDoc &\n  HasType<Decoder> &\n  Partial<ShortDoc & Descriptive & EnvDoc> &\n  AllOrNothing<Default<OutputOf<Decoder>>>;\n\n/**\n * A decoder from `string` to `boolean`\n * works for `true` and `false` only.\n */\nexport const boolean: Type<string, boolean> = {\n  async from(str) {\n    if (str === \"true\") return true;\n    if (str === \"false\") return false;\n    throw new Error(\n      `expected value to be either \"true\" or \"false\". got: \"${str}\"`,\n    );\n  },\n  displayName: \"true/false\",\n  defaultValue: () => false,\n};\n\nexport function fullFlag<Decoder extends Type<boolean, any>>(\n  config: FlagConfig<Decoder>,\n): ArgParser<OutputOf<Decoder>> &\n  ProvidesHelp &\n  Register &\n  Partial<Descriptive> {\n  const decoder = extendType(boolean, config.type);\n\n  return {\n    description: config.description ?? config.type.description,\n    helpTopics() {\n      let usage = `--${config.long}`;\n      if (config.short) {\n        usage += `, -${config.short}`;\n      }\n      const defaults: string[] = [];\n\n      if (config.env) {\n        const env =\n          process.env[config.env] === undefined\n            ? \"\"\n            : `=${chalk.italic(process.env[config.env])}`;\n        defaults.push(`env: ${config.env}${env}`);\n      }\n\n      try {\n        const defaultValueFn = config.defaultValue ?? config.type.defaultValue;\n        const defaultValueIsSerializable =\n          config.defaultValueIsSerializable ??\n          config.type.defaultValueIsSerializable;\n\n        if (defaultValueFn && defaultValueIsSerializable) {\n          const defaultValue = defaultValueFn();\n          defaults.push(`default: ${chalk.italic(defaultValue)}`);\n        }\n      } catch (e) {}\n\n      return [\n        {\n          category: \"flags\",\n          usage,\n          defaults,\n          description:\n            config.description ?? config.type.description ?? \"self explanatory\",\n        },\n      ];\n    },\n    register(opts) {\n      opts.forceFlagLongNames.add(config.long);\n      if (config.short) {\n        opts.forceFlagShortNames.add(config.short);\n      }\n    },\n    async parse({\n      nodes,\n      visitedNodes,\n    }: ParseContext): Promise<ParsingResult<OutputOf<Decoder>>> {\n      const options = findOption(nodes, {\n        longNames: [config.long],\n        shortNames: config.short ? [config.short] : [],\n      }).filter((x) => !visitedNodes.has(x));\n      for (const opt of options) {\n        visitedNodes.add(opt);\n      }\n\n      if (options.length > 1) {\n        return Result.err({\n          errors: [\n            {\n              nodes: options,\n              message: `Expected 1 occurence, got ${options.length}`,\n            },\n          ],\n        });\n      }\n\n      const valueFromEnv = config.env ? process.env[config.env] : undefined;\n      let rawValue: string;\n      let envPrefix = \"\";\n\n      if (options.length === 0 && valueFromEnv !== undefined) {\n        rawValue = valueFromEnv;\n        envPrefix = `env[${chalk.italic(config.env)}]: `;\n      } else if (\n        options.length === 0 &&\n        typeof config.type.defaultValue === \"function\"\n      ) {\n        try {\n          return Result.ok(config.type.defaultValue());\n        } catch (e: any) {\n          const message = `Default value not found for '--${config.long}': ${e.message}`;\n          return Result.err({\n            errors: [{ message, nodes: [] }],\n          });\n        }\n      } else if (options.length === 1) {\n        rawValue = options[0].value?.node.raw ?? \"true\";\n      } else {\n        return Result.err({\n          errors: [\n            { nodes: [], message: `No value provided for --${config.long}` },\n          ],\n        });\n      }\n\n      const decoded = await Result.safeAsync(decoder.from(rawValue));\n\n      if (Result.isErr(decoded)) {\n        return Result.err({\n          errors: [\n            {\n              nodes: options,\n              message: envPrefix + decoded.error.message,\n            },\n          ],\n        });\n      }\n\n      return decoded;\n    },\n  };\n}\n\ntype BooleanType = Type<boolean, boolean>;\n\n/**\n * Decodes an argument which is in the form of a key and a boolean value, and allows parsing the following ways:\n *\n * - `--long` where `long` is the provided `long`\n * - `-s=value` where `s` is the provided `short`\n * Shorthand forms can be combined:\n * - `-abcd` will call all flags for the short forms of `a`, `b`, `c` and `d`.\n * @param config flag configurations\n */\nexport function flag<Decoder extends Type<boolean, any>>(\n  config: FlagConfig<Decoder>,\n): ArgParser<OutputOf<Decoder>> &\n  ProvidesHelp &\n  Register &\n  Partial<Descriptive>;\nexport function flag(\n  config: LongDoc &\n    Partial<HasType<never> & ShortDoc & Descriptive & EnvDoc> &\n    AllOrNothing<Default<OutputOf<BooleanType>>>,\n): ArgParser<OutputOf<BooleanType>> &\n  ProvidesHelp &\n  Register &\n  Partial<Descriptive>;\nexport function flag(\n  config: LongDoc &\n    Partial<HasType<any> & ShortDoc & Descriptive & EnvDoc> &\n    AllOrNothing<Default<OutputOf<any>>>,\n): ArgParser<OutputOf<any>> & ProvidesHelp & Register & Partial<Descriptive> {\n  return fullFlag({\n    type: booleanIdentity,\n    ...config,\n  });\n}\n", "import type { AstNode, LongOption, ShortOption } from \"./parser\";\n\ntype Option = LongOption | ShortOption;\n\n/**\n * A utility function to find an option in the AST\n *\n * @param nodes AST node list\n * @param opts Long and short names to look up\n */\nexport function findOption(\n  nodes: AstNode[],\n  opts: {\n    longNames: string[];\n    shortNames: string[];\n  },\n): Option[] {\n  const result: Option[] = [];\n\n  for (const node of nodes) {\n    if (node.type === \"longOption\" && opts.longNames.includes(node.key)) {\n      result.push(node);\n      continue;\n    }\n\n    if (node.type === \"shortOptions\" && opts.shortNames.length) {\n      for (const option of node.options) {\n        if (opts.shortNames.includes(option.key)) {\n          result.push(option);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n", "export type FromFn<A, B> = (input: A) => Promise<B>;\n\n/** A safe conversion from type A to type B */\nexport type From<A, B> = {\n  /**\n   * Convert `input` safely and asynchronously into an output.\n   */\n  from: FromFn<A, B>;\n};\n\n/** The output of a conversion type or function */\nexport type OutputOf<F extends From<any, any> | FromFn<any, any>> =\n  F extends From<any, infer Output>\n    ? Output\n    : F extends FromFn<any, infer Output>\n      ? Output\n      : never;\n\n/** The input of a conversion type or function */\nexport type InputOf<F extends From<any, any> | FromFn<any, any>> =\n  F extends From<infer Input, any>\n    ? Input\n    : F extends FromFn<infer Input, any>\n      ? Input\n      : never;\n\n/**\n * A type \"conversion\" from any type to itself\n */\nexport function identity<T>(): From<T, T> {\n  return {\n    async from(a) {\n      return a;\n    },\n  };\n}\n", "import type { Default } from \"./default\";\nimport type { From, FromFn, InputOf, OutputOf } from \"./from\";\nimport type { Descriptive, Displayed } from \"./helpdoc\";\n\nexport { identity, type OutputOf, type InputOf } from \"./from\";\n\nexport type Type<From_, To> = From<From_, To> &\n  Partial<Descriptive & Displayed & Default<To>>;\n\n/**\n * Get the type definitions or an empty object from a type or a decoding function\n */\nexport function typeDef<T extends From<any, any> | FromFn<any, any>>(\n  from: T,\n  // biome-ignore lint/complexity/noBannedTypes: TODO\n): T extends FromFn<any, any> ? {} : Omit<T, \"from\"> {\n  if (typeof from === \"function\") {\n    return {} as any;\n  }\n  return from as any;\n}\n\n/**\n * Get the decoding function from a type or a function\n */\nexport function fromFn<A, B>(t: FromFn<A, B> | From<A, B>): FromFn<A, B> {\n  if (typeof t === \"function\") {\n    return t;\n  }\n  return t.from;\n}\n\n/**\n * Extend a type: take a type and use it as a base for another type. Much like using the spread operator:\n * ```\n * const newType = { ...oldType }\n * ```\n * but composes the `from` arguments\n *\n * @param base A base type from `InputA` to `OutputA`\n * @param nextTypeOrDecodingFunction Either an entire `Type<OutputA, AnyOutput>` or just a decoding function from `OutputA` to any type\n */\nexport function extendType<\n  BaseType extends Type<any, any>,\n  NextType extends\n    | Type<OutputOf<BaseType>, any>\n    | FromFn<OutputOf<BaseType>, any>,\n>(\n  base: BaseType,\n  nextTypeOrDecodingFunction: NextType,\n): Omit<BaseType, \"from\" | \"defaultValue\"> &\n  (NextType extends FromFn<any, any> ? unknown : Omit<NextType, \"from\">) &\n  From<InputOf<BaseType>, OutputOf<NextType>> {\n  const {\n    defaultValue: _defaultValue,\n    from: _from,\n    ...t1WithoutDefault\n  } = base;\n  const t2Object = typeDef(nextTypeOrDecodingFunction);\n  const t2From = fromFn(nextTypeOrDecodingFunction);\n\n  return {\n    ...t1WithoutDefault,\n    ...t2Object,\n    async from(a) {\n      const f1Result = await base.from(a);\n      return await t2From(f1Result);\n    },\n  };\n}\n\n/** Contains a type definition inside */\nexport type HasType<T extends Type<any, any>> = {\n  /** The value decoding strategy for this item */\n  type: T;\n};\n", "import { type InputOf, type OutputOf, type Type, identity } from \"./type\";\n\n/**\n * A number type to be used with `option`\n *\n * Throws an error when the provided string is not a number\n */\nexport const number: Type<string, number> = {\n  async from(str) {\n    const decoded = Number.parseFloat(str);\n\n    if (Number.isNaN(decoded)) {\n      throw new Error(\"Not a number\");\n    }\n    return decoded;\n  },\n  displayName: \"number\",\n  description: \"a number\",\n};\n\n/**\n * A string type to be used with `option`.\n */\nexport const string: Type<string, string> = {\n  ...identity(),\n  description: \"a string\",\n  displayName: \"str\",\n};\n\n/**\n * A boolean type to be used with `flag`.\n */\nexport const boolean: Type<boolean, boolean> = {\n  ...identity(),\n  description: \"a boolean\",\n  displayName: \"true/false\",\n  defaultValue() {\n    return false;\n  },\n};\n\n/**\n * Makes any type optional, by defaulting to `undefined`.\n */\nexport function optional<T extends Type<any, any>>(\n  t: T,\n): Type<InputOf<T>, OutputOf<T> | undefined> {\n  return {\n    ...t,\n    defaultValue(): OutputOf<T> | undefined {\n      return undefined;\n    },\n  };\n}\n\n/**\n * Transforms any type into an array, useful for `multioption` and `multiflag`.\n */\n\nexport function array<T extends Type<any, any>>(\n  t: T,\n): Type<InputOf<T>[], OutputOf<T>[]> {\n  return {\n    ...t,\n    async from(inputs: InputOf<T>[]): Promise<OutputOf<T>[]> {\n      return Promise.all(inputs.map((input) => t.from(input)));\n    },\n  };\n}\n", "import * as Result from \"./Result\";\nimport type { ArgParser, ParseContext, Register } from \"./argparser\";\nimport { Exit } from \"./effects\";\nimport { flag } from \"./flag\";\nimport type { PrintHelp, ProvidesHelp, Versioned } from \"./helpdoc\";\nimport { boolean } from \"./types\";\n\ntype CircuitBreaker = \"help\" | \"version\";\n\nexport const helpFlag = flag({\n  long: \"help\",\n  short: \"h\",\n  type: boolean,\n  description: \"show help\",\n});\n\nexport const versionFlag = flag({\n  long: \"version\",\n  short: \"v\",\n  type: boolean,\n  description: \"print the version\",\n});\n\nexport function handleCircuitBreaker(\n  context: ParseContext,\n  value: PrintHelp & Partial<Versioned>,\n  breaker: Result.Result<any, CircuitBreaker>,\n): void {\n  if (Result.isErr(breaker)) {\n    return;\n  }\n\n  if (breaker.value === \"help\") {\n    const message = value.printHelp(context);\n    throw new Exit({\n      exitCode: context.autoFallbackHelpTriggered ? 1 : 0,\n      message,\n      into: \"stdout\",\n    });\n  }\n  if (breaker.value === \"version\") {\n    const message = value.version || \"0.0.0\";\n    throw new Exit({ exitCode: 0, message, into: \"stdout\" });\n  }\n}\n\n/**\n * Helper flags that are being used in `command` and `subcommands`:\n * `--help, -h` to show help\n * `--version, -v` to show the current version\n *\n * It is called circuitbreaker because if you have `--help` or `--version`\n * anywhere in your argument list, you'll see the version and the help for the closest command\n */\nexport function createCircuitBreaker(\n  withVersion: boolean,\n): ArgParser<CircuitBreaker> & ProvidesHelp & Register {\n  return {\n    register(opts) {\n      helpFlag.register(opts);\n      if (withVersion) {\n        versionFlag.register(opts);\n      }\n    },\n    helpTopics() {\n      const helpTopics = helpFlag.helpTopics();\n      if (withVersion) {\n        helpTopics.push(...versionFlag.helpTopics());\n      }\n      return helpTopics;\n    },\n    async parse(context) {\n      const help = await helpFlag.parse(context);\n      const version = withVersion\n        ? await versionFlag.parse(context)\n        : undefined;\n\n      if (Result.isErr(help) || (version && Result.isErr(version))) {\n        const helpErrors = Result.isErr(help) ? help.error.errors : [];\n        const versionErrors =\n          version && Result.isErr(version) ? version.error.errors : [];\n        return Result.err({ errors: [...helpErrors, ...versionErrors] });\n      }\n\n      if (help.value) {\n        return Result.ok(\"help\");\n      }\n      if (version?.value) {\n        return Result.ok(\"version\");\n      }\n      return Result.err({\n        errors: [\n          {\n            nodes: [],\n            message: \"Neither help nor version\",\n          },\n        ],\n      });\n    },\n  };\n}\n", "import chalk from \"chalk\";\nimport * as Result from \"./Result\";\nimport type { ArgParser, ParseContext, ParsingResult } from \"./argparser\";\nimport type { Default } from \"./default\";\nimport type { OutputOf } from \"./from\";\nimport type { Descriptive, Displayed, ProvidesHelp } from \"./helpdoc\";\nimport type { PositionalArgument } from \"./newparser/parser\";\nimport type { HasType, Type } from \"./type\";\nimport { string } from \"./types\";\nimport type { AllOrNothing } from \"./utils\";\n\ntype PositionalConfig<Decoder extends Type<string, any>> = HasType<Decoder> &\n  Partial<Displayed & Descriptive> &\n  AllOrNothing<Default<OutputOf<Decoder>>>;\n\ntype PositionalParser<Decoder extends Type<string, any>> = ArgParser<\n  OutputOf<Decoder>\n> &\n  ProvidesHelp &\n  Partial<Descriptive>;\n\nfunction fullPositional<Decoder extends Type<string, any>>(\n  config: PositionalConfig<Decoder>,\n): PositionalParser<Decoder> {\n  const displayName = config.displayName ?? config.type.displayName ?? \"arg\";\n\n  return {\n    description: config.description ?? config.type.description,\n    helpTopics() {\n      const defaults: string[] = [];\n      const defaultValueFn = config.defaultValue ?? config.type.defaultValue;\n\n      if (defaultValueFn) {\n        try {\n          const defaultValue = defaultValueFn();\n          if (\n            config.defaultValueIsSerializable ??\n            config.type.defaultValueIsSerializable\n          ) {\n            defaults.push(`default: ${chalk.italic(defaultValue)}`);\n          } else {\n            defaults.push(\"optional\");\n          }\n        } catch (e) {}\n      }\n\n      const usage =\n        defaults.length > 0 ? `[${displayName}]` : `<${displayName}>`;\n\n      return [\n        {\n          category: \"arguments\",\n          usage,\n          description:\n            config.description ?? config.type.description ?? \"self explanatory\",\n          defaults,\n        },\n      ];\n    },\n    register(_opts) {},\n    async parse({\n      nodes,\n      visitedNodes,\n    }: ParseContext): Promise<ParsingResult<OutputOf<Decoder>>> {\n      const positionals = nodes.filter(\n        (node): node is PositionalArgument =>\n          node.type === \"positionalArgument\" && !visitedNodes.has(node),\n      );\n\n      const defaultValueFn = config.defaultValue ?? config.type.defaultValue;\n\n      const positional = positionals[0];\n\n      if (!positional) {\n        if (defaultValueFn) {\n          return Result.ok(defaultValueFn());\n        }\n        return Result.err({\n          errors: [\n            {\n              nodes: [],\n              message: `No value provided for ${displayName}`,\n            },\n          ],\n        });\n      }\n\n      visitedNodes.add(positional);\n      const decoded = await Result.safeAsync(config.type.from(positional.raw));\n\n      if (Result.isErr(decoded)) {\n        return Result.err({\n          errors: [\n            {\n              nodes: [positional],\n              message: decoded.error.message,\n            },\n          ],\n        });\n      }\n\n      return Result.ok(decoded.value);\n    },\n  };\n}\n\ntype StringType = Type<string, string>;\n\n/**\n * A positional command line argument.\n *\n * Decodes one argument that is not a flag or an option:\n * In `hello --key value world` we have 2 positional arguments \u2014 `hello` and `world`.\n *\n * @param config positional argument config\n */\nexport function positional<Decoder extends Type<string, any>>(\n  config: HasType<Decoder> & Partial<Displayed & Descriptive>,\n): PositionalParser<Decoder>;\nexport function positional(\n  config?: Partial<HasType<never> & Displayed & Descriptive>,\n): PositionalParser<StringType>;\nexport function positional(\n  config?: Partial<HasType<any>> & Partial<Displayed & Descriptive>,\n): PositionalParser<any> {\n  return fullPositional({\n    type: string,\n    ...config,\n  });\n}\n", "import type { ParseContext } from \"./argparser\";\nimport type { Named } from \"./helpdoc\";\nimport type { Runner } from \"./runner\";\n\n/**\n * A small helper to easily use `process.argv` without dropping context\n *\n * @param cmd a command line parser\n */\n\nexport function binary<Command extends Runner<any, any> & Named>(\n  cmd: Command,\n): Command {\n  return {\n    ...cmd,\n    run(context: ParseContext) {\n      context.anyArgumentsProvided = context.nodes.length > 2;\n      const name = cmd.name || context.nodes[1].raw;\n      context.hotPath?.push(name);\n      context.nodes.splice(0, 1);\n      context.nodes[0].raw = name;\n      context.visitedNodes.add(context.nodes[0]);\n      return cmd.run(context);\n    },\n  };\n}\n", "import chalk from \"chalk\";\nimport * as Result from \"./Result\";\nimport type {\n  ArgParser,\n  ParseContext,\n  ParsingError,\n  ParsingInto,\n  ParsingResult,\n} from \"./argparser\";\nimport { createCircuitBreaker, handleCircuitBreaker } from \"./circuitbreaker\";\nimport type {\n  Aliased,\n  Descriptive,\n  Named,\n  PrintHelp,\n  ProvidesHelp,\n  Versioned,\n} from \"./helpdoc\";\nimport type { AstNode } from \"./newparser/parser\";\nimport type { Runner } from \"./runner\";\nimport { entries, flatMap, groupBy, padNoAnsi } from \"./utils\";\n\ntype ArgTypes = Record<string, ArgParser<any> & Partial<ProvidesHelp>>;\ntype HandlerFunc<Args extends ArgTypes> = (args: Output<Args>) => any;\n\ntype CommandConfig<\n  Arguments extends ArgTypes,\n  Handler extends HandlerFunc<Arguments>,\n> = {\n  args: Arguments;\n  version?: string;\n  name: string;\n  description?: string;\n  handler: Handler;\n  aliases?: string[];\n  noArgsErrorBehaviour?: \"show-help\" | \"show-error\";\n};\n\ntype Output<Args extends ArgTypes> = {\n  [key in keyof Args]: ParsingInto<Args[key]>;\n};\n\n/**\n * A command line utility.\n *\n * A combination of multiple flags, options and arguments\n * with a common name and a handler that expects them as input.\n */\nexport function command<\n  Arguments extends ArgTypes,\n  Handler extends HandlerFunc<Arguments>,\n>(\n  config: CommandConfig<Arguments, Handler>,\n): ArgParser<Output<Arguments>> &\n  PrintHelp &\n  ProvidesHelp &\n  Named &\n  Runner<Output<Arguments>, ReturnType<Handler>> &\n  Partial<Versioned & Descriptive & Aliased> {\n  const argEntries = entries(config.args);\n  const circuitbreaker = createCircuitBreaker(!!config.version);\n\n  return {\n    name: config.name,\n    aliases: config.aliases,\n    handler: config.handler,\n    description: config.description,\n    version: config.version,\n    helpTopics() {\n      return flatMap(\n        Object.values(config.args).concat([circuitbreaker]),\n        (x) => x.helpTopics?.() ?? [],\n      );\n    },\n    printHelp(context) {\n      const lines: string[] = [];\n      let name = context.hotPath?.join(\" \") ?? \"\";\n      if (!name) {\n        name = config.name;\n      }\n\n      name = chalk.bold(name);\n\n      if (config.version) {\n        name += ` ${chalk.dim(config.version)}`;\n      }\n\n      lines.push(name);\n\n      if (config.description) {\n        lines.push(chalk.dim(\"> \") + config.description);\n      }\n\n      const usageBreakdown = groupBy(this.helpTopics(), (x) => x.category);\n\n      for (const [category, helpTopics] of entries(usageBreakdown)) {\n        lines.push(\"\");\n        lines.push(`${category.toUpperCase()}:`);\n        const widestUsage = helpTopics.reduce((len, curr) => {\n          return Math.max(len, curr.usage.length);\n        }, 0);\n        for (const helpTopic of helpTopics) {\n          let line = \"\";\n          line += `  ${padNoAnsi(helpTopic.usage, widestUsage, \"end\")}`;\n          line += \" - \";\n          line += helpTopic.description;\n          for (const defaultValue of helpTopic.defaults) {\n            line += chalk.dim(` [${defaultValue}]`);\n          }\n          lines.push(line);\n        }\n      }\n\n      return lines.join(\"\\n\");\n    },\n    register(opts) {\n      for (const [, arg] of argEntries) {\n        arg.register?.(opts);\n      }\n    },\n    async parse(\n      context: ParseContext,\n    ): Promise<ParsingResult<Output<Arguments>>> {\n      if (context.hotPath?.length === 0) {\n        context.hotPath.push(config.name);\n      }\n\n      const resultObject = {} as Output<Arguments>;\n      const errors: ParsingError[] = [];\n\n      for (const [argName, arg] of argEntries) {\n        const result = await arg.parse(context);\n        if (Result.isErr(result)) {\n          errors.push(...result.error.errors);\n        } else {\n          resultObject[argName] = result.value;\n        }\n      }\n\n      const unknownArguments: AstNode[] = [];\n      for (const node of context.nodes) {\n        if (context.visitedNodes.has(node)) {\n          continue;\n        }\n\n        if (node.type === \"forcePositional\") {\n          // A `forcePositional` node can't really be visited since it has no meaning\n          // other than forcing a positional argument in the parsing phase\n          continue;\n        }\n        if (node.type === \"shortOptions\") {\n          for (const option of node.options) {\n            if (context.visitedNodes.has(option)) {\n              continue;\n            }\n            unknownArguments.push(option);\n          }\n        } else {\n          unknownArguments.push(node);\n        }\n      }\n\n      if (unknownArguments.length > 0) {\n        errors.push({\n          message: \"Unknown arguments\",\n          nodes: unknownArguments,\n        });\n      }\n\n      if (errors.length > 0) {\n        return Result.err({\n          errors: errors,\n          partialValue: resultObject,\n        });\n      }\n      return Result.ok(resultObject);\n    },\n    async run(context) {\n      context.anyArgumentsProvided ??= context.nodes.length > 0;\n      let breaker = await circuitbreaker.parse(context);\n      const parsed = await this.parse(context);\n\n      if (\n        Result.isErr(parsed) &&\n        config.noArgsErrorBehaviour !== \"show-error\" &&\n        !context.anyArgumentsProvided\n      ) {\n        breaker = Result.ok(\"help\");\n        context.autoFallbackHelpTriggered = true;\n      }\n      handleCircuitBreaker(context, this, breaker);\n\n      if (Result.isErr(parsed)) {\n        return Result.err(parsed.error);\n      }\n\n      return Result.ok(await this.handler(parsed.value));\n    },\n  };\n}\n", "import stripAnsi from \"strip-ansi\";\n\n/**\n * @ignore\n */\nexport function padNoAnsi(\n  str: string,\n  length: number,\n  place: \"end\" | \"start\",\n): string {\n  const noAnsiStr = stripAnsi(str);\n  if (length < noAnsiStr.length) return str;\n  const pad = Array(length - noAnsiStr.length + 1).join(\" \");\n  if (place === \"end\") {\n    return str + pad;\n  }\n  return pad + str;\n}\n\n/**\n * Group an array by a function that returns the key\n *\n * @ignore\n */\nexport function groupBy<A, B extends string>(\n  objs: A[],\n  f: (a: A) => B,\n): Record<B, A[]> {\n  const result = {} as Record<B, A[]>;\n  for (const obj of objs) {\n    const key = f(obj);\n    result[key] = result[key] ?? [];\n    result[key].push(obj);\n  }\n  return result;\n}\n\n/**\n * A better typed version of `Object.entries`\n *\n * @ignore\n */\nexport function entries<Obj extends Record<string, any>>(\n  obj: Obj,\n): { [key in keyof Obj]: [key, Obj[key]] }[keyof Obj][] {\n  return Object.entries(obj);\n}\n\n/**\n * Enumerate over a list, to get a pair of [index, value]\n *\n * @ignore\n */\nexport function* enumerate<T>(arr: T[]): Generator<[number, T]> {\n  for (let i = 0; i < arr.length; i++) {\n    yield [i, arr[i]];\n  }\n}\n\n/**\n * Array#flatMap polyfill\n *\n * @ignore\n */\nexport function flatMap<A, B>(xs: A[], fn: (a: A) => B[]): B[] {\n  const results: B[] = [];\n  for (const x of xs) {\n    results.push(...fn(x));\n  }\n  return results;\n}\n\n/**\n * Flatten an array\n *\n * @ignore\n */\nexport function flatten<A>(xs: A[][]): A[] {\n  const results: A[] = [];\n  for (const x of xs) {\n    results.push(...x);\n  }\n  return results;\n}\n\n/**\n * Either the provided `T` or an empty object\n */\nexport type AllOrNothing<T> = T | { [key in keyof T]?: never };\n", "import chalk from \"chalk\";\nimport * as Result from \"./Result\";\nimport type {\n  ArgParser,\n  ParseContext,\n  ParsingError,\n  ParsingResult,\n} from \"./argparser\";\nimport type { Default } from \"./default\";\nimport type { OutputOf } from \"./from\";\nimport type {\n  Descriptive,\n  EnvDoc,\n  LongDoc,\n  ProvidesHelp,\n  ShortDoc,\n} from \"./helpdoc\";\nimport { findOption } from \"./newparser/findOption\";\nimport type { HasType, Type } from \"./type\";\nimport { string } from \"./types\";\nimport type { AllOrNothing } from \"./utils\";\n\ntype OptionConfig<Decoder extends Type<string, any>> = LongDoc &\n  HasType<Decoder> &\n  Partial<Descriptive & EnvDoc & ShortDoc> &\n  AllOrNothing<Default<OutputOf<Decoder>>>;\n\nfunction fullOption<Decoder extends Type<string, any>>(\n  config: OptionConfig<Decoder>,\n): ArgParser<OutputOf<Decoder>> & ProvidesHelp & Partial<Descriptive> {\n  return {\n    description: config.description ?? config.type.description,\n    helpTopics() {\n      const displayName = config.type.displayName ?? \"value\";\n      let usage = `--${config.long}`;\n      if (config.short) {\n        usage += `, -${config.short}`;\n      }\n      usage += ` <${displayName}>`;\n\n      const defaults: string[] = [];\n\n      if (config.env) {\n        const env =\n          process.env[config.env] === undefined\n            ? \"\"\n            : `=${chalk.italic(process.env[config.env])}`;\n        defaults.push(`env: ${config.env}${env}`);\n      }\n\n      const defaultValueFn = config.defaultValue ?? config.type.defaultValue;\n\n      if (defaultValueFn) {\n        try {\n          const defaultValue = defaultValueFn();\n          if (\n            config.defaultValueIsSerializable ??\n            config.type.defaultValueIsSerializable\n          ) {\n            defaults.push(`default: ${chalk.italic(defaultValue)}`);\n          } else {\n            defaults.push(\"optional\");\n          }\n        } catch (e) {}\n      }\n\n      return [\n        {\n          category: \"options\",\n          usage,\n          defaults,\n          description:\n            config.description ?? config.type.description ?? \"self explanatory\",\n        },\n      ];\n    },\n    register(opts) {\n      opts.forceOptionLongNames.add(config.long);\n      if (config.short) {\n        opts.forceOptionShortNames.add(config.short);\n      }\n    },\n    async parse({\n      nodes,\n      visitedNodes,\n    }: ParseContext): Promise<ParsingResult<OutputOf<Decoder>>> {\n      const options = findOption(nodes, {\n        longNames: [config.long],\n        shortNames: config.short ? [config.short] : [],\n      }).filter((x) => !visitedNodes.has(x));\n\n      for (const opt of options) {\n        visitedNodes.add(opt);\n      }\n\n      if (options.length > 1) {\n        const error: ParsingError = {\n          message: `Too many times provided. Expected 1, got: ${options.length}`,\n          nodes: options,\n        };\n        return Result.err({ errors: [error] });\n      }\n\n      const valueFromEnv = config.env ? process.env[config.env] : undefined;\n\n      const option = options[0];\n      let rawValue: string;\n      let envPrefix = \"\";\n      const defaultValueFn = config.defaultValue ?? config.type.defaultValue;\n\n      if (option?.value) {\n        rawValue = option.value.node.raw;\n      } else if (valueFromEnv !== undefined) {\n        rawValue = valueFromEnv;\n        envPrefix = `env[${chalk.italic(config.env)}]: `;\n      } else if (!option && typeof defaultValueFn === \"function\") {\n        try {\n          return Result.ok(defaultValueFn());\n        } catch (e: any) {\n          const message = `Default value not found for '--${config.long}': ${e.message}`;\n          return Result.err({\n            errors: [\n              {\n                nodes: [],\n                message,\n              },\n            ],\n          });\n        }\n      } else {\n        const raw =\n          option?.type === \"shortOption\"\n            ? `-${option?.key}`\n            : `--${option?.key ?? config.long}`;\n        return Result.err({\n          errors: [\n            {\n              nodes: options,\n              message: `No value provided for ${raw}`,\n            },\n          ],\n        });\n      }\n\n      const decoded = await Result.safeAsync(config.type.from(rawValue));\n      if (Result.isErr(decoded)) {\n        return Result.err({\n          errors: [\n            { nodes: options, message: envPrefix + decoded.error.message },\n          ],\n        });\n      }\n\n      return Result.ok(decoded.value);\n    },\n  };\n}\n\ntype StringType = Type<string, string>;\n\n/**\n * Decodes an argument which is in the form of a key and a value, and allows parsing the following ways:\n *\n * - `--long=value` where `long` is the provided `long`\n * - `--long value` where `long` is the provided `long`\n * - `-s=value` where `s` is the provided `short`\n * - `-s value` where `s` is the provided `short`\n * @param config flag configurations\n */\nexport function option<Decoder extends Type<string, any>>(\n  config: LongDoc &\n    HasType<Decoder> &\n    Partial<Descriptive & EnvDoc & ShortDoc> &\n    AllOrNothing<Default<OutputOf<Decoder>>>,\n): ArgParser<OutputOf<Decoder>> & ProvidesHelp & Partial<Descriptive>;\nexport function option(\n  config: LongDoc &\n    Partial<HasType<never> & Descriptive & EnvDoc & ShortDoc> &\n    AllOrNothing<Default<OutputOf<StringType>>>,\n): ArgParser<OutputOf<StringType>> & ProvidesHelp & Partial<Descriptive>;\nexport function option(\n  config: LongDoc &\n    Partial<HasType<any>> &\n    Partial<Descriptive & EnvDoc & ShortDoc>,\n): ArgParser<OutputOf<any>> & ProvidesHelp & Partial<Descriptive> {\n  return fullOption({\n    type: string,\n    ...config,\n  });\n}\n", "import chalk from \"chalk\";\nimport stripAnsi from \"strip-ansi\";\nimport type { ParsingError } from \"./argparser\";\nimport type { AstNode } from \"./newparser/parser\";\nimport { enumerate, padNoAnsi } from \"./utils\";\n\ntype HighlightResult = { colorized: string; errorIndex: number };\n\n/**\n * Get the input as highlighted keywords to show to the user\n * with the error that was generated from parsing the input.\n *\n * @param nodes AST nodes\n * @param error A parsing error\n */\nfunction highlight(\n  nodes: AstNode[],\n  error: ParsingError,\n): HighlightResult | undefined {\n  const strings: string[] = [];\n  let errorIndex: undefined | number = undefined;\n\n  function foundError() {\n    if (errorIndex !== undefined) return;\n    errorIndex = stripAnsi(strings.join(\" \")).length;\n  }\n\n  if (error.nodes.length === 0) return;\n\n  for (const node of nodes) {\n    if (error.nodes.includes(node)) {\n      foundError();\n      strings.push(chalk.red(node.raw));\n      return; // TODO: check that this type fix didn't break program semantics.\n    }\n    if (node.type === \"shortOptions\") {\n      let failed = false;\n      let s = \"\";\n      for (const option of node.options) {\n        if (error.nodes.includes(option)) {\n          s += chalk.red(option.raw);\n          failed = true;\n        } else {\n          s += chalk.dim(option.raw);\n        }\n      }\n      const prefix = failed ? chalk.red(\"-\") : chalk.dim(\"-\");\n      if (failed) {\n        foundError();\n      }\n      strings.push(prefix + s);\n      return; // TODO: check that this type fix didn't break program semantics.\n    }\n\n    strings.push(chalk.dim(node.raw));\n    return; // TODO: check that this type fix didn't break program semantics.\n  }\n\n  return { colorized: strings.join(\" \"), errorIndex: errorIndex ?? 0 };\n}\n\n/**\n * An error UI\n *\n * @param breadcrumbs The command breadcrumbs to print with the error\n */\nexport function errorBox(\n  nodes: AstNode[],\n  errors: ParsingError[],\n  breadcrumbs: string[],\n): string {\n  const withHighlight: { message: string; highlighted?: HighlightResult }[] =\n    [];\n\n  const errorMessages: string[] = [];\n\n  for (const error of errors) {\n    const highlighted = highlight(nodes, error);\n    withHighlight.push({ message: error.message, highlighted });\n  }\n\n  let number = 1;\n  const maxNumberWidth = String(withHighlight.length).length;\n\n  errorMessages.push(\n    `${chalk.red.bold(\"error: \")}found ${chalk.yellow(withHighlight.length)} error${withHighlight.length > 1 ? \"s\" : \"\"}`,\n  );\n  errorMessages.push(\"\");\n\n  // biome-ignore lint/complexity/noForEach: TODO\n  withHighlight\n    .filter((x) => x.highlighted)\n    .forEach((x) => {\n      if (!x.highlighted) {\n        throw new Error(\"WELP\");\n      }\n\n      const pad = \"\".padStart(x.highlighted.errorIndex);\n\n      errorMessages.push(`  ${x.highlighted.colorized}`);\n      for (const [index, line] of enumerate(x.message.split(\"\\n\"))) {\n        const prefix = index === 0 ? chalk.bold(\"^\") : \" \";\n        const msg = chalk.red(`  ${pad} ${prefix} ${line}`);\n        errorMessages.push(msg);\n      }\n      errorMessages.push(\"\");\n      number++;\n    });\n\n  const withNoHighlight = withHighlight.filter((x) => !x.highlighted);\n\n  if (number > 1) {\n    if (withNoHighlight.length === 1) {\n      errorMessages.push(\"Along with the following error:\");\n    } else if (withNoHighlight.length > 1) {\n      errorMessages.push(\"Along with the following errors:\");\n    }\n  }\n\n  // biome-ignore lint/complexity/noForEach: TODO\n  withNoHighlight.forEach(({ message }) => {\n    const num = chalk.red.bold(\n      `${padNoAnsi(number.toString(), maxNumberWidth, \"start\")}.`,\n    );\n    errorMessages.push(`  ${num} ${chalk.red(message)}`);\n    number++;\n  });\n\n  const helpCmd = chalk.yellow(`${breadcrumbs.join(\" \")} --help`);\n\n  errorMessages.push(\"\");\n  errorMessages.push(\n    `${chalk.red.bold(\"hint: \")}for more information, try '${helpCmd}'`,\n  );\n\n  return errorMessages.join(\"\\n\");\n}\n", "import createDebugger from \"debug\";\nimport type { RegisterOptions } from \"../argparser\";\nimport type { Token } from \"./tokenizer\";\n\nconst debug = createDebugger(\"cmd-ts:parser\");\n\nexport type AstNode =\n  | Value\n  | LongOption\n  | ShortOption\n  | ShortOptions\n  | PositionalArgument\n  | ForcePositional;\n\ntype BaseAstNode<Type extends string> = {\n  type: Type;\n  index: number;\n  raw: string;\n};\n\nexport interface LongOption extends BaseAstNode<\"longOption\"> {\n  key: string;\n  value?: OptionValue;\n}\n\ninterface Delimiter extends BaseAstNode<\"delimiter\"> {}\n\ninterface Value extends BaseAstNode<\"value\"> {}\n\ninterface OptionValue extends BaseAstNode<\"optionValue\"> {\n  delimiter: Delimiter;\n  node: Value;\n}\n\nexport interface ShortOptions extends BaseAstNode<\"shortOptions\"> {\n  options: ShortOption[];\n}\n\nexport interface ShortOption extends BaseAstNode<\"shortOption\"> {\n  key: string;\n  value?: OptionValue;\n}\n\nexport interface PositionalArgument extends BaseAstNode<\"positionalArgument\"> {}\n\ninterface ForcePositional extends BaseAstNode<\"forcePositional\"> {\n  type: \"forcePositional\";\n}\n\n/**\n * Create an AST from a token list\n *\n * @param tokens A token list, coming from `tokenizer.ts`\n * @param forceFlag Keys to force as flag. {@see ForceFlag} to read more about it.\n */\nexport function parse(tokens: Token[], forceFlag: RegisterOptions): AstNode[] {\n  if (debug.enabled) {\n    const registered = {\n      shortFlags: [...forceFlag.forceFlagShortNames],\n      longFlags: [...forceFlag.forceFlagLongNames],\n      shortOptions: [...forceFlag.forceOptionShortNames],\n      longOptions: [...forceFlag.forceOptionLongNames],\n    };\n    debug(\"Registered:\", JSON.stringify(registered));\n  }\n\n  const nodes: AstNode[] = [];\n  let index = 0;\n  let forcedPositional = false;\n\n  function getToken(): Token | undefined {\n    return tokens[index++];\n  }\n\n  function peekToken(): Token | undefined {\n    return tokens[index];\n  }\n\n  while (index < tokens.length) {\n    const currentToken = getToken();\n    if (!currentToken) break;\n\n    if (currentToken.type === \"argumentDivider\") {\n      continue;\n    }\n\n    if (forcedPositional) {\n      let str = currentToken.raw;\n      let nextToken = getToken();\n      while (nextToken && nextToken?.type !== \"argumentDivider\") {\n        str += nextToken.raw;\n        nextToken = getToken();\n      }\n      nodes.push({\n        type: \"positionalArgument\",\n        index: currentToken.index,\n        raw: str,\n      });\n      continue;\n    }\n\n    if (currentToken.type === \"char\") {\n      let str = currentToken.raw;\n      let nextToken = getToken();\n      while (nextToken && nextToken?.type !== \"argumentDivider\") {\n        str += nextToken.raw;\n        nextToken = getToken();\n      }\n      nodes.push({\n        type: \"positionalArgument\",\n        index: currentToken.index,\n        raw: str,\n      });\n      continue;\n    }\n\n    if (currentToken.type === \"longPrefix\") {\n      let nextToken = getToken();\n\n      if (nextToken?.type === \"argumentDivider\" || !nextToken) {\n        nodes.push({\n          type: \"forcePositional\",\n          index: currentToken.index,\n          raw: \"--\",\n        });\n        forcedPositional = true;\n        continue;\n      }\n\n      let key = \"\";\n      while (\n        nextToken &&\n        nextToken?.raw !== \"=\" &&\n        nextToken?.type !== \"argumentDivider\"\n      ) {\n        key += nextToken.raw;\n        nextToken = getToken();\n      }\n\n      const parsedValue = parseOptionValue({\n        key,\n        delimiterToken: nextToken,\n        forceFlag: forceFlag.forceFlagLongNames,\n        getToken,\n        peekToken,\n        forceOption: forceFlag.forceOptionLongNames,\n      });\n      let raw = `--${key}`;\n\n      if (parsedValue) {\n        raw += parsedValue.raw;\n      }\n\n      nodes.push({\n        type: \"longOption\",\n        key,\n        index: currentToken.index,\n        raw,\n        value: parsedValue,\n      });\n      continue;\n    }\n\n    if (currentToken.type === \"shortPrefix\") {\n      const keys: Token[] = [];\n      let nextToken = getToken();\n\n      if (nextToken?.type === \"argumentDivider\" || !nextToken) {\n        nodes.push({\n          type: \"positionalArgument\",\n          index: currentToken.index,\n          raw: \"-\",\n        });\n        continue;\n      }\n\n      while (\n        nextToken &&\n        nextToken?.type !== \"argumentDivider\" &&\n        nextToken?.raw !== \"=\"\n      ) {\n        keys.push(nextToken);\n        nextToken = getToken();\n      }\n\n      // biome-ignore lint/style/noNonNullAssertion: TODO\n      const lastKey = keys.pop()!;\n      const parsedValue = parseOptionValue({\n        key: lastKey.raw,\n        delimiterToken: nextToken,\n        forceFlag: forceFlag.forceFlagShortNames,\n        forceOption: forceFlag.forceOptionShortNames,\n        getToken,\n        peekToken,\n      });\n\n      const options: ShortOption[] = [];\n\n      for (const key of keys) {\n        options.push({\n          type: \"shortOption\",\n          index: key.index,\n          raw: key.raw,\n          key: key.raw,\n        });\n      }\n\n      let lastKeyRaw = lastKey.raw;\n\n      if (parsedValue) {\n        lastKeyRaw += parsedValue.raw;\n      }\n\n      options.push({\n        type: \"shortOption\",\n        index: lastKey.index,\n        raw: lastKeyRaw,\n        value: parsedValue,\n        key: lastKey.raw,\n      });\n\n      let optionsRaw = `-${keys.map((x) => x.raw).join(\"\")}${lastKey.raw}`;\n      if (parsedValue) {\n        optionsRaw += parsedValue.raw;\n      }\n\n      const shortOptions: ShortOptions = {\n        type: \"shortOptions\",\n        index: currentToken.index,\n        raw: optionsRaw,\n        options,\n      };\n\n      nodes.push(shortOptions);\n      continue;\n    }\n\n    index++;\n    // biome-ignore lint/correctness/noUnnecessaryContinue: TODO\n    continue;\n  }\n\n  if (debug.enabled) {\n    const objectNodes = nodes.map((node) => ({ [node.type]: node.raw }));\n    debug(\"Parsed items:\", JSON.stringify(objectNodes));\n  }\n\n  return nodes;\n}\n\nfunction parseOptionValue(opts: {\n  delimiterToken?: Token;\n  getToken(): Token | undefined;\n  peekToken(): Token | undefined;\n  key: string;\n  forceFlag: Set<string>;\n  forceOption: Set<string>;\n}): OptionValue | undefined {\n  const { getToken, delimiterToken, forceFlag, key, forceOption } = opts;\n  const shouldReadKeyAsOption = forceOption.has(key);\n  const shouldReadKeyAsFlag =\n    !shouldReadKeyAsOption &&\n    (forceFlag.has(key) || opts.peekToken()?.type !== \"char\");\n\n  if (!delimiterToken || (delimiterToken.raw !== \"=\" && shouldReadKeyAsFlag)) {\n    return;\n  }\n\n  const delimiter = delimiterToken.raw === \"=\" ? \"=\" : \" \";\n  const delimiterIndex = delimiterToken.index;\n\n  let nextToken = getToken();\n  if (!nextToken) {\n    return;\n  }\n\n  let value = \"\";\n  const valueIndex = nextToken.index;\n  while (nextToken && nextToken?.type !== \"argumentDivider\") {\n    value += nextToken.raw;\n    nextToken = getToken();\n  }\n\n  return {\n    type: \"optionValue\",\n    index: delimiterToken.index,\n    delimiter: { type: \"delimiter\", raw: delimiter, index: delimiterIndex },\n    node: { type: \"value\", raw: value, index: valueIndex },\n    raw: `${delimiter}${value}`,\n  };\n}\n", "import { enumerate } from \"../utils\";\n\nexport type Token =\n  | { index: number; type: \"argumentDivider\"; raw: \" \" }\n  | {\n      index: number;\n      type: \"shortPrefix\";\n      raw: \"-\";\n    }\n  | {\n      index: number;\n      type: \"longPrefix\";\n      raw: \"--\";\n    }\n  | {\n      index: number;\n      type: \"char\";\n      raw: string;\n    };\n\n/**\n * Tokenize a list of arguments\n *\n * @param strings arguments, based on `process.argv`\n */\nexport function tokenize(strings: string[]): Token[] {\n  const tokens: Token[] = [];\n  let overallIndex = 0;\n\n  const push = (token: Token) => {\n    tokens.push(token);\n    overallIndex += token.raw.length;\n  };\n\n  for (const [stringIndex, string] of enumerate(strings)) {\n    const chars = [...string];\n    for (let i = 0; i < chars.length; i++) {\n      if (chars[i] === \"-\" && chars[i + 1] === \"-\") {\n        push({ type: \"longPrefix\", raw: \"--\", index: overallIndex });\n        i++;\n      } else if (chars[i] === \"-\") {\n        push({ type: \"shortPrefix\", raw: \"-\", index: overallIndex });\n      } else {\n        push({ type: \"char\", raw: chars[i], index: overallIndex });\n      }\n    }\n\n    if (stringIndex + 1 !== strings.length) {\n      push({ type: \"argumentDivider\", raw: \" \", index: overallIndex });\n    }\n  }\n\n  return tokens;\n}\n", "import { type Result, err, isErr, ok } from \"./Result\";\nimport type {\n  ArgParser,\n  ParseContext,\n  ParsingResult,\n  Register,\n} from \"./argparser\";\nimport { Exit } from \"./effects\";\nimport { errorBox } from \"./errorBox\";\nimport type { PrintHelp, Versioned } from \"./helpdoc\";\nimport { type AstNode, parse as doParse } from \"./newparser/parser\";\nimport { tokenize } from \"./newparser/tokenizer\";\n\nexport type Handling<Values, Result> = { handler: (values: Values) => Result };\n\nexport type Runner<HandlerArgs, HandlerResult> = PrintHelp &\n  Partial<Versioned> &\n  Register &\n  Handling<HandlerArgs, HandlerResult> &\n  ArgParser<HandlerArgs> & {\n    run(context: ParseContext): Promise<ParsingResult<HandlerResult>>;\n  };\n\nexport type Into<R extends Runner<any, any>> = R extends Runner<any, infer X>\n  ? X\n  : never;\n\nexport async function run<R extends Runner<any, any>>(\n  ap: R,\n  strings: string[],\n): Promise<Into<R>> {\n  const result = await runSafely(ap, strings);\n  if (isErr(result)) {\n    return result.error.run();\n  }\n  return result.value;\n}\n\n/**\n * Runs a command but does not apply any effect\n */\nexport async function runSafely<R extends Runner<any, any>>(\n  ap: R,\n  strings: string[],\n): Promise<Result<Exit, Into<R>>> {\n  const hotPath: string[] = [];\n  const nodes = parseCommon(ap, strings);\n\n  try {\n    const result = await ap.run({ nodes, visitedNodes: new Set(), hotPath });\n\n    if (isErr(result)) {\n      throw new Exit({\n        message: errorBox(nodes, result.error.errors, hotPath),\n        exitCode: 1,\n        into: \"stderr\",\n      });\n    }\n    return ok(result.value);\n  } catch (e) {\n    if (e instanceof Exit) {\n      return err(e);\n    }\n    throw e;\n  }\n}\n\n/**\n * Run a command but don't quit. Returns an `Result` instead.\n */\nexport async function dryRun<R extends Runner<any, any>>(\n  ap: R,\n  strings: string[],\n): Promise<Result<string, Into<R>>> {\n  const result = await runSafely(ap, strings);\n  if (isErr(result)) {\n    return err(result.error.dryRun());\n  }\n  return result;\n}\n\n/**\n * Parse the command as if to run it, but only return the parse result and don't run the command.\n */\nexport function parse<R extends Runner<any, any>>(\n  ap: R,\n  strings: string[],\n): Promise<ParsingResult<any>> {\n  const hotPath: string[] = [];\n  const nodes = parseCommon(ap, strings);\n  return ap.parse({ nodes, visitedNodes: new Set(), hotPath });\n}\n\nfunction parseCommon<R extends Runner<any, any>>(\n  ap: R,\n  strings: string[],\n): AstNode[] {\n  const longFlagKeys = new Set<string>();\n  const shortFlagKeys = new Set<string>();\n  const longOptionKeys = new Set<string>();\n  const shortOptionKeys = new Set<string>();\n  const registerContext = {\n    forceFlagShortNames: shortFlagKeys,\n    forceFlagLongNames: longFlagKeys,\n    forceOptionShortNames: shortOptionKeys,\n    forceOptionLongNames: longOptionKeys,\n  };\n\n  ap.register(registerContext);\n\n  const tokens = tokenize(strings);\n  return doParse(tokens, registerContext);\n}\n", "import * as Result from \"./Result\";\nimport type {\n  ArgParser,\n  ParseContext,\n  ParsingError,\n  ParsingResult,\n} from \"./argparser\";\nimport type { OutputOf } from \"./from\";\nimport type { Descriptive, Displayed, ProvidesHelp } from \"./helpdoc\";\nimport type { PositionalArgument } from \"./newparser/parser\";\nimport type { HasType, Type } from \"./type\";\nimport { string } from \"./types\";\n\ntype RestPositionalsConfig<Decoder extends Type<string, any>> =\n  HasType<Decoder> & Partial<Displayed & Descriptive>;\n\n/**\n * Read all the positionals and decode them using the type provided.\n * Works best when it is the last item on the `command` construct, to be\n * used like the `...rest` operator in JS and TypeScript.\n */\nfunction fullRestPositionals<Decoder extends Type<string, any>>(\n  config: RestPositionalsConfig<Decoder>,\n): ArgParser<OutputOf<Decoder>[]> & ProvidesHelp {\n  return {\n    helpTopics() {\n      const displayName =\n        config.displayName ?? config.type.displayName ?? \"arg\";\n      return [\n        {\n          usage: `[...${displayName}]`,\n          category: \"arguments\",\n          defaults: [],\n          description: config.description ?? config.type.description ?? \"\",\n        },\n      ];\n    },\n    register(_opts) {},\n    async parse({\n      nodes,\n      visitedNodes,\n    }: ParseContext): Promise<ParsingResult<OutputOf<Decoder>[]>> {\n      const positionals = nodes.filter(\n        (node): node is PositionalArgument =>\n          node.type === \"positionalArgument\" && !visitedNodes.has(node),\n      );\n\n      const results: OutputOf<Decoder>[] = [];\n      const errors: ParsingError[] = [];\n\n      for (const positional of positionals) {\n        visitedNodes.add(positional);\n        const decoded = await Result.safeAsync(\n          config.type.from(positional.raw),\n        );\n        if (Result.isOk(decoded)) {\n          results.push(decoded.value);\n        } else {\n          errors.push({\n            nodes: [positional],\n            message: decoded.error.message,\n          });\n        }\n      }\n\n      if (errors.length > 0) {\n        return Result.err({\n          errors,\n        });\n      }\n\n      return Result.ok(results);\n    },\n  };\n}\n\ntype StringType = Type<string, string>;\n\ntype RestPositionalsParser<Decoder extends Type<string, any>> = ArgParser<\n  OutputOf<Decoder>[]\n> &\n  ProvidesHelp;\n\n/**\n * Read all the positionals and decode them using the type provided.\n * Works best when it is the last item on the `command` construct, to be\n * used like the `...rest` operator in JS and TypeScript.\n *\n * @param config rest positionals argument config\n */\nexport function restPositionals<Decoder extends Type<string, any>>(\n  config: HasType<Decoder> & Partial<Displayed & Descriptive>,\n): RestPositionalsParser<Decoder>;\nexport function restPositionals(\n  config?: Partial<HasType<never> & Displayed & Descriptive>,\n): RestPositionalsParser<StringType>;\nexport function restPositionals(\n  config?: Partial<HasType<any>> & Partial<Displayed & Descriptive>,\n): RestPositionalsParser<any> {\n  return fullRestPositionals({\n    type: string,\n    ...config,\n  });\n}\n", "import * as Result from \"./Result\";\nimport type {\n  ArgParser,\n  ParseContext,\n  ParsingError,\n  ParsingResult,\n} from \"./argparser\";\nimport { boolean } from \"./flag\";\nimport type { From, OutputOf } from \"./from\";\nimport type { Descriptive, LongDoc, ProvidesHelp, ShortDoc } from \"./helpdoc\";\nimport { findOption } from \"./newparser/findOption\";\nimport type { HasType } from \"./type\";\n\ntype MultiFlagConfig<Decoder extends From<boolean[], any>> = HasType<Decoder> &\n  LongDoc &\n  Partial<Descriptive & ShortDoc>;\n\n/**\n * Like `option`, but can accept multiple options, and expects a decoder from a list of strings.\n * An error will highlight all option occurences.\n */\nexport function multiflag<Decoder extends From<boolean[], any>>(\n  config: MultiFlagConfig<Decoder>,\n): ArgParser<OutputOf<Decoder>> & ProvidesHelp {\n  return {\n    helpTopics() {\n      let usage = `--${config.long}`;\n      if (config.short) {\n        usage += `, -${config.short}`;\n      }\n      return [\n        {\n          category: \"flags\",\n          usage,\n          defaults: [],\n          description: config.description ?? \"self explanatory\",\n        },\n      ];\n    },\n    register(opts) {\n      opts.forceFlagLongNames.add(config.long);\n      if (config.short) {\n        opts.forceFlagShortNames.add(config.short);\n      }\n    },\n    async parse({\n      nodes,\n      visitedNodes,\n    }: ParseContext): Promise<ParsingResult<OutputOf<Decoder>>> {\n      const options = findOption(nodes, {\n        longNames: [config.long],\n        shortNames: config.short ? [config.short] : [],\n      }).filter((x) => !visitedNodes.has(x));\n\n      for (const option of options) {\n        visitedNodes.add(option);\n      }\n\n      const optionValues: boolean[] = [];\n      const errors: ParsingError[] = [];\n\n      for (const option of options) {\n        const decoded = await Result.safeAsync(\n          boolean.from(option.value?.node.raw ?? \"true\"),\n        );\n        if (Result.isErr(decoded)) {\n          errors.push({ nodes: [option], message: decoded.error.message });\n        } else {\n          optionValues.push(decoded.value);\n        }\n      }\n\n      if (errors.length > 0) {\n        return Result.err({\n          errors,\n        });\n      }\n\n      const multiDecoded = await Result.safeAsync(\n        config.type.from(optionValues),\n      );\n\n      if (Result.isErr(multiDecoded)) {\n        return Result.err({\n          errors: [\n            {\n              nodes: options,\n              message: multiDecoded.error.message,\n            },\n          ],\n        });\n      }\n\n      return multiDecoded;\n    },\n  };\n}\n", "import chalk from \"chalk\";\nimport * as Result from \"./Result\";\nimport type {\n  ArgParser,\n  ParseContext,\n  ParsingError,\n  ParsingResult,\n  Register,\n} from \"./argparser\";\nimport type { Default } from \"./default\";\nimport type { OutputOf } from \"./from\";\nimport type { Descriptive, LongDoc, ProvidesHelp, ShortDoc } from \"./helpdoc\";\nimport { findOption } from \"./newparser/findOption\";\nimport type { AstNode } from \"./newparser/parser\";\nimport type { HasType, Type } from \"./type\";\n\ntype MultiOptionConfig<Decoder extends Type<string[], any>> = HasType<Decoder> &\n  LongDoc &\n  Partial<ShortDoc & Descriptive & Default<OutputOf<Decoder>>>;\n\n/**\n * Like `option`, but can accept multiple options, and expects a decoder from a list of strings.\n * An error will highlight all option occurences.\n */\nexport function multioption<Decoder extends Type<string[], any>>(\n  config: MultiOptionConfig<Decoder>,\n): ArgParser<OutputOf<Decoder>> & ProvidesHelp & Register {\n  return {\n    helpTopics() {\n      const displayName = config.type.displayName ?? \"value\";\n      let usage = `--${config.long} <${displayName}>`;\n      if (config.short) {\n        usage += `, -${config.short}=<${displayName}>`;\n      }\n\n      const defaults: string[] = [];\n\n      const defaultValueFn = config.defaultValue ?? config.type.defaultValue;\n\n      if (defaultValueFn) {\n        try {\n          const defaultValue = defaultValueFn();\n          if (\n            config.defaultValueIsSerializable ??\n            config.type.defaultValueIsSerializable\n          ) {\n            defaults.push(`default: ${chalk.italic(defaultValue)}`);\n          } else {\n            defaults.push(\"[...optional]\");\n          }\n        } catch (e) {}\n      }\n\n      return [\n        {\n          category: \"options\",\n          usage,\n          defaults,\n          description: config.description ?? \"self explanatory\",\n        },\n      ];\n    },\n    register(opts) {\n      opts.forceOptionLongNames.add(config.long);\n      if (config.short) {\n        opts.forceOptionShortNames.add(config.short);\n      }\n    },\n    async parse({\n      nodes,\n      visitedNodes,\n    }: ParseContext): Promise<ParsingResult<OutputOf<Decoder>>> {\n      const options = findOption(nodes, {\n        longNames: [config.long],\n        shortNames: config.short ? [config.short] : [],\n      }).filter((x) => !visitedNodes.has(x));\n\n      const defaultValueFn = config.defaultValue ?? config.type.defaultValue;\n\n      if (options.length === 0 && typeof defaultValueFn === \"function\") {\n        try {\n          return Result.ok(defaultValueFn());\n        } catch (e: any) {\n          const message = `Failed to resolve default value for '--${config.long}': ${e.message}`;\n          return Result.err({\n            errors: [\n              {\n                nodes: [],\n                message,\n              },\n            ],\n          });\n        }\n      }\n\n      for (const option of options) {\n        visitedNodes.add(option);\n      }\n\n      const optionValues: string[] = [];\n      const errors: ParsingError[] = [];\n      const flagNodes: AstNode[] = [];\n\n      for (const option of options) {\n        const providedValue = option.value?.node.raw;\n        if (providedValue === undefined) {\n          flagNodes.push(option);\n          continue;\n        }\n        optionValues.push(providedValue);\n      }\n\n      if (flagNodes.length > 0) {\n        errors.push({\n          nodes: flagNodes,\n          message: \"Expected to get a value, found a flag\",\n        });\n      }\n\n      if (errors.length > 0) {\n        return Result.err({ errors });\n      }\n\n      const multiDecoded = await Result.safeAsync(\n        config.type.from(optionValues),\n      );\n\n      if (Result.isErr(multiDecoded)) {\n        return Result.err({\n          errors: [{ nodes: options, message: multiDecoded.error.message }],\n        });\n      }\n\n      return multiDecoded;\n    },\n  };\n}\n", "import * as Result from \"./Result\";\nimport type { From, FromFn, InputOf, OutputOf } from \"./from\";\nimport { type Type, fromFn, typeDef } from \"./type\";\n\ntype Any<A = any> = FromFn<A, any> | From<A, any>;\n\n/**\n * Take one of the types. Merge the metadata from left to right.\n * If nothing matches, prints all the errors.\n */\nexport function union<T1 extends Any, T2s extends Any<InputOf<T1>>>(\n  ts: [T1, ...T2s[]],\n  {\n    combineErrors = (errors) => errors.join(\"\\n\"),\n  }: {\n    /**\n     * Combine all the errors produced by the types.\n     * Defaults to joining them with a newline.\n     */\n    combineErrors?(errors: string[]): string;\n  } = {},\n): Type<InputOf<T1>, OutputOf<T1 | T2s>> {\n  const merged = Object.assign({}, ...ts.map((x) => typeDef(x)));\n  return {\n    ...merged,\n    async from(input) {\n      const errors: string[] = [];\n\n      for (const t of ts) {\n        const decoded = await Result.safeAsync(fromFn(t)(input));\n        if (Result.isOk(decoded)) {\n          return decoded.value;\n        }\n        errors.push(decoded.error.message);\n      }\n\n      throw new Error(combineErrors(errors));\n    },\n  };\n}\n", "import { inspect } from \"node:util\";\nimport type { Type } from \"./type\";\n\n/**\n * A union of literals. When you want to take an exact enum value.\n */\nexport function oneOf<T extends string>(\n  literals: readonly T[],\n): Type<string, T> {\n  const examples = literals.map((x) => inspect(x)).join(\", \");\n  return {\n    async from(str) {\n      const value = literals.find((x) => x === str);\n      if (!value) {\n        throw new Error(`Invalid value '${str}'. Expected one of: ${examples}`);\n      }\n      return value;\n    },\n    description: `One of ${examples}`,\n  };\n}\n", "import * as Result from \"./Result\";\nimport type { ArgParser } from \"./argparser\";\nimport type { Descriptive, Displayed, ProvidesHelp } from \"./helpdoc\";\n\nexport function rest(\n  config?: Partial<Displayed & Descriptive>,\n): ArgParser<string[]> & ProvidesHelp {\n  return {\n    helpTopics() {\n      const displayName = config?.displayName ?? \"arg\";\n      return [\n        {\n          usage: `[...${displayName}]`,\n          category: \"arguments\",\n          defaults: [],\n          description: config?.description ?? \"catches the rest of the values\",\n        },\n      ];\n    },\n    register() {},\n    async parse(context) {\n      const visitedNodeIndices = [...context.visitedNodes]\n        .map((x) => context.nodes.indexOf(x))\n        .filter((x) => x > -1);\n      if (visitedNodeIndices.length === 0) {\n        return Result.ok([]);\n      }\n\n      const maxIndex = Math.max(...visitedNodeIndices);\n      const restItems = context.nodes.slice(maxIndex + 1);\n      for (const node of restItems) {\n        context.visitedNodes.add(node);\n      }\n      return Result.ok(restItems.map((x) => x.raw));\n    },\n  };\n}\n"],
  "mappings": "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",
  "names": ["chalk", "chalk", "option", "boolean", "chalk", "chalk", "chalk", "positional", "cmd", "option", "chalk", "array", "chalk", "flatMap", "flatMap", "chalk", "option", "chalk", "chalk", "option", "chalk", "stripAnsi", "stripAnsi", "chalk", "option", "number", "string", "parse", "positional", "option", "boolean", "chalk", "chalk", "option"]
}
