// src/subcommands.ts
import chalk4 from "chalk";
import didYouMean from "didyoumean";

// src/Result.ts
function ok(value) {
  return { _tag: "ok", value };
}
function err(error) {
  return { _tag: "error", error };
}
function isOk(result) {
  return result._tag === "ok";
}
function isErr(either) {
  return either._tag === "error";
}
async function safeAsync(promise) {
  try {
    const value = await promise;
    return ok(value);
  } catch (e) {
    return err(e);
  }
}

// src/effects.ts
import chalk from "chalk";
var Exit = class {
  constructor(config) {
    this.config = config;
  }
  run() {
    const output = this.output();
    output(this.config.message);
    process.exit(this.config.exitCode);
  }
  dryRun() {
    const { into, message, exitCode } = this.config;
    const coloredExit = chalk.dim(
      `process exited with status ${exitCode} (${into})`
    );
    return `${message}

${coloredExit}`;
  }
  output() {
    if (this.config.into === "stderr") {
      return console.error;
    }
    return console.log;
  }
};

// src/flag.ts
import chalk2 from "chalk";

// src/newparser/findOption.ts
function findOption(nodes, opts) {
  const result = [];
  for (const node of nodes) {
    if (node.type === "longOption" && opts.longNames.includes(node.key)) {
      result.push(node);
      continue;
    }
    if (node.type === "shortOptions" && opts.shortNames.length) {
      for (const option2 of node.options) {
        if (opts.shortNames.includes(option2.key)) {
          result.push(option2);
        }
      }
    }
  }
  return result;
}

// src/from.ts
function identity() {
  return {
    async from(a) {
      return a;
    }
  };
}

// src/type.ts
function typeDef(from) {
  if (typeof from === "function") {
    return {};
  }
  return from;
}
function fromFn(t) {
  if (typeof t === "function") {
    return t;
  }
  return t.from;
}
function extendType(base, nextTypeOrDecodingFunction) {
  const {
    defaultValue: _defaultValue,
    from: _from,
    ...t1WithoutDefault
  } = base;
  const t2Object = typeDef(nextTypeOrDecodingFunction);
  const t2From = fromFn(nextTypeOrDecodingFunction);
  return {
    ...t1WithoutDefault,
    ...t2Object,
    async from(a) {
      const f1Result = await base.from(a);
      return await t2From(f1Result);
    }
  };
}

// src/types.ts
var number = {
  async from(str) {
    const decoded = Number.parseFloat(str);
    if (Number.isNaN(decoded)) {
      throw new Error("Not a number");
    }
    return decoded;
  },
  displayName: "number",
  description: "a number"
};
var string = {
  ...identity(),
  description: "a string",
  displayName: "str"
};
var boolean = {
  ...identity(),
  description: "a boolean",
  displayName: "true/false",
  defaultValue() {
    return false;
  }
};
function optional(t) {
  return {
    ...t,
    defaultValue() {
      return void 0;
    }
  };
}
function array(t) {
  return {
    ...t,
    async from(inputs) {
      return Promise.all(inputs.map((input) => t.from(input)));
    }
  };
}

// src/flag.ts
var boolean2 = {
  async from(str) {
    if (str === "true") return true;
    if (str === "false") return false;
    throw new Error(
      `expected value to be either "true" or "false". got: "${str}"`
    );
  },
  displayName: "true/false",
  defaultValue: () => false
};
function fullFlag(config) {
  const decoder = extendType(boolean2, config.type);
  return {
    description: config.description ?? config.type.description,
    helpTopics() {
      let usage = `--${config.long}`;
      if (config.short) {
        usage += `, -${config.short}`;
      }
      const defaults = [];
      if (config.env) {
        const env = process.env[config.env] === void 0 ? "" : `=${chalk2.italic(process.env[config.env])}`;
        defaults.push(`env: ${config.env}${env}`);
      }
      try {
        const defaultValueFn = config.defaultValue ?? config.type.defaultValue;
        const defaultValueIsSerializable = config.defaultValueIsSerializable ?? config.type.defaultValueIsSerializable;
        if (defaultValueFn && defaultValueIsSerializable) {
          const defaultValue = defaultValueFn();
          defaults.push(`default: ${chalk2.italic(defaultValue)}`);
        }
      } catch (e) {
      }
      return [
        {
          category: "flags",
          usage,
          defaults,
          description: config.description ?? config.type.description ?? "self explanatory"
        }
      ];
    },
    register(opts) {
      opts.forceFlagLongNames.add(config.long);
      if (config.short) {
        opts.forceFlagShortNames.add(config.short);
      }
    },
    async parse({
      nodes,
      visitedNodes
    }) {
      const options = findOption(nodes, {
        longNames: [config.long],
        shortNames: config.short ? [config.short] : []
      }).filter((x) => !visitedNodes.has(x));
      for (const opt of options) {
        visitedNodes.add(opt);
      }
      if (options.length > 1) {
        return err({
          errors: [
            {
              nodes: options,
              message: `Expected 1 occurence, got ${options.length}`
            }
          ]
        });
      }
      const valueFromEnv = config.env ? process.env[config.env] : void 0;
      let rawValue;
      let envPrefix = "";
      if (options.length === 0 && valueFromEnv !== void 0) {
        rawValue = valueFromEnv;
        envPrefix = `env[${chalk2.italic(config.env)}]: `;
      } else if (options.length === 0 && typeof config.type.defaultValue === "function") {
        try {
          return ok(config.type.defaultValue());
        } catch (e) {
          const message = `Default value not found for '--${config.long}': ${e.message}`;
          return err({
            errors: [{ message, nodes: [] }]
          });
        }
      } else if (options.length === 1) {
        rawValue = options[0].value?.node.raw ?? "true";
      } else {
        return err({
          errors: [
            { nodes: [], message: `No value provided for --${config.long}` }
          ]
        });
      }
      const decoded = await safeAsync(decoder.from(rawValue));
      if (isErr(decoded)) {
        return err({
          errors: [
            {
              nodes: options,
              message: envPrefix + decoded.error.message
            }
          ]
        });
      }
      return decoded;
    }
  };
}
function flag(config) {
  return fullFlag({
    type: boolean,
    ...config
  });
}

// src/circuitbreaker.ts
var helpFlag = flag({
  long: "help",
  short: "h",
  type: boolean,
  description: "show help"
});
var versionFlag = flag({
  long: "version",
  short: "v",
  type: boolean,
  description: "print the version"
});
function handleCircuitBreaker(context, value, breaker) {
  if (isErr(breaker)) {
    return;
  }
  if (breaker.value === "help") {
    const message = value.printHelp(context);
    throw new Exit({
      exitCode: context.autoFallbackHelpTriggered ? 1 : 0,
      message,
      into: "stdout"
    });
  }
  if (breaker.value === "version") {
    const message = value.version || "0.0.0";
    throw new Exit({ exitCode: 0, message, into: "stdout" });
  }
}
function createCircuitBreaker(withVersion) {
  return {
    register(opts) {
      helpFlag.register(opts);
      if (withVersion) {
        versionFlag.register(opts);
      }
    },
    helpTopics() {
      const helpTopics = helpFlag.helpTopics();
      if (withVersion) {
        helpTopics.push(...versionFlag.helpTopics());
      }
      return helpTopics;
    },
    async parse(context) {
      const help = await helpFlag.parse(context);
      const version = withVersion ? await versionFlag.parse(context) : void 0;
      if (isErr(help) || version && isErr(version)) {
        const helpErrors = isErr(help) ? help.error.errors : [];
        const versionErrors = version && isErr(version) ? version.error.errors : [];
        return err({ errors: [...helpErrors, ...versionErrors] });
      }
      if (help.value) {
        return ok("help");
      }
      if (version?.value) {
        return ok("version");
      }
      return err({
        errors: [
          {
            nodes: [],
            message: "Neither help nor version"
          }
        ]
      });
    }
  };
}

// src/positional.ts
import chalk3 from "chalk";
function fullPositional(config) {
  const displayName = config.displayName ?? config.type.displayName ?? "arg";
  return {
    description: config.description ?? config.type.description,
    helpTopics() {
      const defaults = [];
      const defaultValueFn = config.defaultValue ?? config.type.defaultValue;
      if (defaultValueFn) {
        try {
          const defaultValue = defaultValueFn();
          if (config.defaultValueIsSerializable ?? config.type.defaultValueIsSerializable) {
            defaults.push(`default: ${chalk3.italic(defaultValue)}`);
          } else {
            defaults.push("optional");
          }
        } catch (e) {
        }
      }
      const usage = defaults.length > 0 ? `[${displayName}]` : `<${displayName}>`;
      return [
        {
          category: "arguments",
          usage,
          description: config.description ?? config.type.description ?? "self explanatory",
          defaults
        }
      ];
    },
    register(_opts) {
    },
    async parse({
      nodes,
      visitedNodes
    }) {
      const positionals = nodes.filter(
        (node) => node.type === "positionalArgument" && !visitedNodes.has(node)
      );
      const defaultValueFn = config.defaultValue ?? config.type.defaultValue;
      const positional2 = positionals[0];
      if (!positional2) {
        if (defaultValueFn) {
          return ok(defaultValueFn());
        }
        return err({
          errors: [
            {
              nodes: [],
              message: `No value provided for ${displayName}`
            }
          ]
        });
      }
      visitedNodes.add(positional2);
      const decoded = await safeAsync(config.type.from(positional2.raw));
      if (isErr(decoded)) {
        return err({
          errors: [
            {
              nodes: [positional2],
              message: decoded.error.message
            }
          ]
        });
      }
      return ok(decoded.value);
    }
  };
}
function positional(config) {
  return fullPositional({
    type: string,
    ...config
  });
}

// src/subcommands.ts
function subcommands(config) {
  const circuitbreaker = createCircuitBreaker(!!config.version);
  const type = {
    async from(str) {
      const commands = Object.entries(config.cmds).map(([name, cmd2]) => {
        return {
          cmdName: name,
          names: [name, ...cmd2.aliases ?? []]
        };
      });
      const cmd = commands.find((x) => x.names.includes(str));
      if (cmd) {
        return cmd.cmdName;
      }
      let errorMessage = "Not a valid subcommand name";
      const closeOptions = didYouMean(
        str,
        flatMap(commands, (x) => x.names)
      );
      if (closeOptions) {
        const option2 = Array.isArray(closeOptions) ? closeOptions[0] : closeOptions;
        errorMessage += `
Did you mean ${chalk4.italic(option2)}?`;
      }
      throw new Error(errorMessage);
    }
  };
  const subcommand = positional({
    displayName: "subcommand",
    description: `one of ${Object.keys(config.cmds).join(", ")}`,
    type
  });
  function normalizeContext(context) {
    if (context.hotPath?.length === 0) {
      context.hotPath.push(config.name);
    }
    if (!context.nodes.some((n) => !context.visitedNodes.has(n))) {
      context.autoFallbackHelpTriggered = true;
      context.nodes.push({
        type: "longOption",
        index: 0,
        key: "help",
        raw: "--help"
      });
    }
  }
  return {
    version: config.version,
    description: config.description,
    name: config.name,
    handler: (value) => {
      const cmd = config.cmds[value.command];
      return cmd.handler(value.args);
    },
    register(opts) {
      for (const cmd of Object.values(config.cmds)) {
        cmd.register(opts);
      }
      circuitbreaker.register(opts);
    },
    printHelp(context) {
      const lines = [];
      const argsSoFar = context.hotPath?.join(" ") ?? "cli";
      lines.push(chalk4.bold(argsSoFar + chalk4.italic(" <subcommand>")));
      if (config.description) {
        lines.push(chalk4.dim("> ") + config.description);
      }
      lines.push("");
      lines.push(`where ${chalk4.italic("<subcommand>")} can be one of:`);
      lines.push("");
      for (const key of Object.keys(config.cmds)) {
        const cmd = config.cmds[key];
        let description = cmd.description ?? "";
        description = description && ` - ${description} `;
        if (cmd.aliases?.length) {
          const aliasTxt = cmd.aliases.length === 1 ? "alias" : "aliases";
          const aliases = cmd.aliases.join(", ");
          description += chalk4.dim(`[${aliasTxt}: ${aliases}]`);
        }
        const row = chalk4.dim("- ") + key + description;
        lines.push(row.trim());
      }
      const helpCommand = chalk4.yellow(`${argsSoFar} <subcommand> --help`);
      lines.push("");
      lines.push(chalk4.dim(`For more help, try running \`${helpCommand}\``));
      return lines.join("\n");
    },
    async parse(context) {
      normalizeContext(context);
      const parsed = await subcommand.parse(context);
      if (isErr(parsed)) {
        return err({
          errors: parsed.error.errors,
          partialValue: {}
        });
      }
      context.hotPath?.push(parsed.value);
      const cmd = config.cmds[parsed.value];
      const parsedCommand = await cmd.parse(context);
      if (isErr(parsedCommand)) {
        return err({
          errors: parsedCommand.error.errors,
          partialValue: {
            command: parsed.value,
            args: parsedCommand.error.partialValue
          }
        });
      }
      return ok({
        args: parsedCommand.value,
        command: parsed.value
      });
    },
    async run(context) {
      normalizeContext(context);
      const parsedSubcommand = await subcommand.parse(context);
      if (isErr(parsedSubcommand)) {
        const breaker = await circuitbreaker.parse(context);
        handleCircuitBreaker(context, this, breaker);
        return err({ ...parsedSubcommand.error, partialValue: {} });
      }
      context.hotPath?.push(parsedSubcommand.value);
      const cmd = config.cmds[parsedSubcommand.value];
      const commandRun = await cmd.run(context);
      if (isOk(commandRun)) {
        return ok({
          command: parsedSubcommand.value,
          value: commandRun.value
        });
      }
      return err({
        ...commandRun.error,
        partialValue: {
          command: parsedSubcommand.value,
          value: commandRun.error.partialValue
        }
      });
    }
  };
}
function flatMap(array2, f) {
  const rs = [];
  for (const item of array2) {
    rs.push(...f(item));
  }
  return rs;
}

// src/binary.ts
function binary(cmd) {
  return {
    ...cmd,
    run(context) {
      context.anyArgumentsProvided = context.nodes.length > 2;
      const name = cmd.name || context.nodes[1].raw;
      context.hotPath?.push(name);
      context.nodes.splice(0, 1);
      context.nodes[0].raw = name;
      context.visitedNodes.add(context.nodes[0]);
      return cmd.run(context);
    }
  };
}

// src/command.ts
import chalk5 from "chalk";

// src/utils.ts
import stripAnsi from "strip-ansi";
function padNoAnsi(str, length, place) {
  const noAnsiStr = stripAnsi(str);
  if (length < noAnsiStr.length) return str;
  const pad = Array(length - noAnsiStr.length + 1).join(" ");
  if (place === "end") {
    return str + pad;
  }
  return pad + str;
}
function groupBy(objs, f) {
  const result = {};
  for (const obj of objs) {
    const key = f(obj);
    result[key] = result[key] ?? [];
    result[key].push(obj);
  }
  return result;
}
function entries(obj) {
  return Object.entries(obj);
}
function* enumerate(arr) {
  for (let i = 0; i < arr.length; i++) {
    yield [i, arr[i]];
  }
}
function flatMap2(xs, fn) {
  const results = [];
  for (const x of xs) {
    results.push(...fn(x));
  }
  return results;
}

// src/command.ts
function command(config) {
  const argEntries = entries(config.args);
  const circuitbreaker = createCircuitBreaker(!!config.version);
  return {
    name: config.name,
    aliases: config.aliases,
    handler: config.handler,
    description: config.description,
    version: config.version,
    helpTopics() {
      return flatMap2(
        Object.values(config.args).concat([circuitbreaker]),
        (x) => x.helpTopics?.() ?? []
      );
    },
    printHelp(context) {
      const lines = [];
      let name = context.hotPath?.join(" ") ?? "";
      if (!name) {
        name = config.name;
      }
      name = chalk5.bold(name);
      if (config.version) {
        name += ` ${chalk5.dim(config.version)}`;
      }
      lines.push(name);
      if (config.description) {
        lines.push(chalk5.dim("> ") + config.description);
      }
      const usageBreakdown = groupBy(this.helpTopics(), (x) => x.category);
      for (const [category, helpTopics] of entries(usageBreakdown)) {
        lines.push("");
        lines.push(`${category.toUpperCase()}:`);
        const widestUsage = helpTopics.reduce((len, curr) => {
          return Math.max(len, curr.usage.length);
        }, 0);
        for (const helpTopic of helpTopics) {
          let line = "";
          line += `  ${padNoAnsi(helpTopic.usage, widestUsage, "end")}`;
          line += " - ";
          line += helpTopic.description;
          for (const defaultValue of helpTopic.defaults) {
            line += chalk5.dim(` [${defaultValue}]`);
          }
          lines.push(line);
        }
      }
      return lines.join("\n");
    },
    register(opts) {
      for (const [, arg] of argEntries) {
        arg.register?.(opts);
      }
    },
    async parse(context) {
      if (context.hotPath?.length === 0) {
        context.hotPath.push(config.name);
      }
      const resultObject = {};
      const errors = [];
      for (const [argName, arg] of argEntries) {
        const result = await arg.parse(context);
        if (isErr(result)) {
          errors.push(...result.error.errors);
        } else {
          resultObject[argName] = result.value;
        }
      }
      const unknownArguments = [];
      for (const node of context.nodes) {
        if (context.visitedNodes.has(node)) {
          continue;
        }
        if (node.type === "forcePositional") {
          continue;
        }
        if (node.type === "shortOptions") {
          for (const option2 of node.options) {
            if (context.visitedNodes.has(option2)) {
              continue;
            }
            unknownArguments.push(option2);
          }
        } else {
          unknownArguments.push(node);
        }
      }
      if (unknownArguments.length > 0) {
        errors.push({
          message: "Unknown arguments",
          nodes: unknownArguments
        });
      }
      if (errors.length > 0) {
        return err({
          errors,
          partialValue: resultObject
        });
      }
      return ok(resultObject);
    },
    async run(context) {
      context.anyArgumentsProvided ??= context.nodes.length > 0;
      let breaker = await circuitbreaker.parse(context);
      const parsed = await this.parse(context);
      if (isErr(parsed) && config.noArgsErrorBehaviour !== "show-error" && !context.anyArgumentsProvided) {
        breaker = ok("help");
        context.autoFallbackHelpTriggered = true;
      }
      handleCircuitBreaker(context, this, breaker);
      if (isErr(parsed)) {
        return err(parsed.error);
      }
      return ok(await this.handler(parsed.value));
    }
  };
}

// src/option.ts
import chalk6 from "chalk";
function fullOption(config) {
  return {
    description: config.description ?? config.type.description,
    helpTopics() {
      const displayName = config.type.displayName ?? "value";
      let usage = `--${config.long}`;
      if (config.short) {
        usage += `, -${config.short}`;
      }
      usage += ` <${displayName}>`;
      const defaults = [];
      if (config.env) {
        const env = process.env[config.env] === void 0 ? "" : `=${chalk6.italic(process.env[config.env])}`;
        defaults.push(`env: ${config.env}${env}`);
      }
      const defaultValueFn = config.defaultValue ?? config.type.defaultValue;
      if (defaultValueFn) {
        try {
          const defaultValue = defaultValueFn();
          if (config.defaultValueIsSerializable ?? config.type.defaultValueIsSerializable) {
            defaults.push(`default: ${chalk6.italic(defaultValue)}`);
          } else {
            defaults.push("optional");
          }
        } catch (e) {
        }
      }
      return [
        {
          category: "options",
          usage,
          defaults,
          description: config.description ?? config.type.description ?? "self explanatory"
        }
      ];
    },
    register(opts) {
      opts.forceOptionLongNames.add(config.long);
      if (config.short) {
        opts.forceOptionShortNames.add(config.short);
      }
    },
    async parse({
      nodes,
      visitedNodes
    }) {
      const options = findOption(nodes, {
        longNames: [config.long],
        shortNames: config.short ? [config.short] : []
      }).filter((x) => !visitedNodes.has(x));
      for (const opt of options) {
        visitedNodes.add(opt);
      }
      if (options.length > 1) {
        const error = {
          message: `Too many times provided. Expected 1, got: ${options.length}`,
          nodes: options
        };
        return err({ errors: [error] });
      }
      const valueFromEnv = config.env ? process.env[config.env] : void 0;
      const option2 = options[0];
      let rawValue;
      let envPrefix = "";
      const defaultValueFn = config.defaultValue ?? config.type.defaultValue;
      if (option2?.value) {
        rawValue = option2.value.node.raw;
      } else if (valueFromEnv !== void 0) {
        rawValue = valueFromEnv;
        envPrefix = `env[${chalk6.italic(config.env)}]: `;
      } else if (!option2 && typeof defaultValueFn === "function") {
        try {
          return ok(defaultValueFn());
        } catch (e) {
          const message = `Default value not found for '--${config.long}': ${e.message}`;
          return err({
            errors: [
              {
                nodes: [],
                message
              }
            ]
          });
        }
      } else {
        const raw = option2?.type === "shortOption" ? `-${option2?.key}` : `--${option2?.key ?? config.long}`;
        return err({
          errors: [
            {
              nodes: options,
              message: `No value provided for ${raw}`
            }
          ]
        });
      }
      const decoded = await safeAsync(config.type.from(rawValue));
      if (isErr(decoded)) {
        return err({
          errors: [
            { nodes: options, message: envPrefix + decoded.error.message }
          ]
        });
      }
      return ok(decoded.value);
    }
  };
}
function option(config) {
  return fullOption({
    type: string,
    ...config
  });
}

// src/errorBox.ts
import chalk7 from "chalk";
import stripAnsi2 from "strip-ansi";
function highlight(nodes, error) {
  const strings = [];
  let errorIndex = void 0;
  function foundError() {
    if (errorIndex !== void 0) return;
    errorIndex = stripAnsi2(strings.join(" ")).length;
  }
  if (error.nodes.length === 0) return;
  for (const node of nodes) {
    if (error.nodes.includes(node)) {
      foundError();
      strings.push(chalk7.red(node.raw));
      return;
    }
    if (node.type === "shortOptions") {
      let failed = false;
      let s = "";
      for (const option2 of node.options) {
        if (error.nodes.includes(option2)) {
          s += chalk7.red(option2.raw);
          failed = true;
        } else {
          s += chalk7.dim(option2.raw);
        }
      }
      const prefix = failed ? chalk7.red("-") : chalk7.dim("-");
      if (failed) {
        foundError();
      }
      strings.push(prefix + s);
      return;
    }
    strings.push(chalk7.dim(node.raw));
    return;
  }
  return { colorized: strings.join(" "), errorIndex: errorIndex ?? 0 };
}
function errorBox(nodes, errors, breadcrumbs) {
  const withHighlight = [];
  const errorMessages = [];
  for (const error of errors) {
    const highlighted = highlight(nodes, error);
    withHighlight.push({ message: error.message, highlighted });
  }
  let number2 = 1;
  const maxNumberWidth = String(withHighlight.length).length;
  errorMessages.push(
    `${chalk7.red.bold("error: ")}found ${chalk7.yellow(withHighlight.length)} error${withHighlight.length > 1 ? "s" : ""}`
  );
  errorMessages.push("");
  withHighlight.filter((x) => x.highlighted).forEach((x) => {
    if (!x.highlighted) {
      throw new Error("WELP");
    }
    const pad = "".padStart(x.highlighted.errorIndex);
    errorMessages.push(`  ${x.highlighted.colorized}`);
    for (const [index, line] of enumerate(x.message.split("\n"))) {
      const prefix = index === 0 ? chalk7.bold("^") : " ";
      const msg = chalk7.red(`  ${pad} ${prefix} ${line}`);
      errorMessages.push(msg);
    }
    errorMessages.push("");
    number2++;
  });
  const withNoHighlight = withHighlight.filter((x) => !x.highlighted);
  if (number2 > 1) {
    if (withNoHighlight.length === 1) {
      errorMessages.push("Along with the following error:");
    } else if (withNoHighlight.length > 1) {
      errorMessages.push("Along with the following errors:");
    }
  }
  withNoHighlight.forEach(({ message }) => {
    const num = chalk7.red.bold(
      `${padNoAnsi(number2.toString(), maxNumberWidth, "start")}.`
    );
    errorMessages.push(`  ${num} ${chalk7.red(message)}`);
    number2++;
  });
  const helpCmd = chalk7.yellow(`${breadcrumbs.join(" ")} --help`);
  errorMessages.push("");
  errorMessages.push(
    `${chalk7.red.bold("hint: ")}for more information, try '${helpCmd}'`
  );
  return errorMessages.join("\n");
}

// src/newparser/parser.ts
import createDebugger from "debug";
var debug = createDebugger("cmd-ts:parser");
function parse(tokens, forceFlag) {
  if (debug.enabled) {
    const registered = {
      shortFlags: [...forceFlag.forceFlagShortNames],
      longFlags: [...forceFlag.forceFlagLongNames],
      shortOptions: [...forceFlag.forceOptionShortNames],
      longOptions: [...forceFlag.forceOptionLongNames]
    };
    debug("Registered:", JSON.stringify(registered));
  }
  const nodes = [];
  let index = 0;
  let forcedPositional = false;
  function getToken() {
    return tokens[index++];
  }
  function peekToken() {
    return tokens[index];
  }
  while (index < tokens.length) {
    const currentToken = getToken();
    if (!currentToken) break;
    if (currentToken.type === "argumentDivider") {
      continue;
    }
    if (forcedPositional) {
      let str = currentToken.raw;
      let nextToken = getToken();
      while (nextToken && nextToken?.type !== "argumentDivider") {
        str += nextToken.raw;
        nextToken = getToken();
      }
      nodes.push({
        type: "positionalArgument",
        index: currentToken.index,
        raw: str
      });
      continue;
    }
    if (currentToken.type === "char") {
      let str = currentToken.raw;
      let nextToken = getToken();
      while (nextToken && nextToken?.type !== "argumentDivider") {
        str += nextToken.raw;
        nextToken = getToken();
      }
      nodes.push({
        type: "positionalArgument",
        index: currentToken.index,
        raw: str
      });
      continue;
    }
    if (currentToken.type === "longPrefix") {
      let nextToken = getToken();
      if (nextToken?.type === "argumentDivider" || !nextToken) {
        nodes.push({
          type: "forcePositional",
          index: currentToken.index,
          raw: "--"
        });
        forcedPositional = true;
        continue;
      }
      let key = "";
      while (nextToken && nextToken?.raw !== "=" && nextToken?.type !== "argumentDivider") {
        key += nextToken.raw;
        nextToken = getToken();
      }
      const parsedValue = parseOptionValue({
        key,
        delimiterToken: nextToken,
        forceFlag: forceFlag.forceFlagLongNames,
        getToken,
        peekToken,
        forceOption: forceFlag.forceOptionLongNames
      });
      let raw = `--${key}`;
      if (parsedValue) {
        raw += parsedValue.raw;
      }
      nodes.push({
        type: "longOption",
        key,
        index: currentToken.index,
        raw,
        value: parsedValue
      });
      continue;
    }
    if (currentToken.type === "shortPrefix") {
      const keys = [];
      let nextToken = getToken();
      if (nextToken?.type === "argumentDivider" || !nextToken) {
        nodes.push({
          type: "positionalArgument",
          index: currentToken.index,
          raw: "-"
        });
        continue;
      }
      while (nextToken && nextToken?.type !== "argumentDivider" && nextToken?.raw !== "=") {
        keys.push(nextToken);
        nextToken = getToken();
      }
      const lastKey = keys.pop();
      const parsedValue = parseOptionValue({
        key: lastKey.raw,
        delimiterToken: nextToken,
        forceFlag: forceFlag.forceFlagShortNames,
        forceOption: forceFlag.forceOptionShortNames,
        getToken,
        peekToken
      });
      const options = [];
      for (const key of keys) {
        options.push({
          type: "shortOption",
          index: key.index,
          raw: key.raw,
          key: key.raw
        });
      }
      let lastKeyRaw = lastKey.raw;
      if (parsedValue) {
        lastKeyRaw += parsedValue.raw;
      }
      options.push({
        type: "shortOption",
        index: lastKey.index,
        raw: lastKeyRaw,
        value: parsedValue,
        key: lastKey.raw
      });
      let optionsRaw = `-${keys.map((x) => x.raw).join("")}${lastKey.raw}`;
      if (parsedValue) {
        optionsRaw += parsedValue.raw;
      }
      const shortOptions = {
        type: "shortOptions",
        index: currentToken.index,
        raw: optionsRaw,
        options
      };
      nodes.push(shortOptions);
      continue;
    }
    index++;
    continue;
  }
  if (debug.enabled) {
    const objectNodes = nodes.map((node) => ({ [node.type]: node.raw }));
    debug("Parsed items:", JSON.stringify(objectNodes));
  }
  return nodes;
}
function parseOptionValue(opts) {
  const { getToken, delimiterToken, forceFlag, key, forceOption } = opts;
  const shouldReadKeyAsOption = forceOption.has(key);
  const shouldReadKeyAsFlag = !shouldReadKeyAsOption && (forceFlag.has(key) || opts.peekToken()?.type !== "char");
  if (!delimiterToken || delimiterToken.raw !== "=" && shouldReadKeyAsFlag) {
    return;
  }
  const delimiter = delimiterToken.raw === "=" ? "=" : " ";
  const delimiterIndex = delimiterToken.index;
  let nextToken = getToken();
  if (!nextToken) {
    return;
  }
  let value = "";
  const valueIndex = nextToken.index;
  while (nextToken && nextToken?.type !== "argumentDivider") {
    value += nextToken.raw;
    nextToken = getToken();
  }
  return {
    type: "optionValue",
    index: delimiterToken.index,
    delimiter: { type: "delimiter", raw: delimiter, index: delimiterIndex },
    node: { type: "value", raw: value, index: valueIndex },
    raw: `${delimiter}${value}`
  };
}

// src/newparser/tokenizer.ts
function tokenize(strings) {
  const tokens = [];
  let overallIndex = 0;
  const push = (token) => {
    tokens.push(token);
    overallIndex += token.raw.length;
  };
  for (const [stringIndex, string2] of enumerate(strings)) {
    const chars = [...string2];
    for (let i = 0; i < chars.length; i++) {
      if (chars[i] === "-" && chars[i + 1] === "-") {
        push({ type: "longPrefix", raw: "--", index: overallIndex });
        i++;
      } else if (chars[i] === "-") {
        push({ type: "shortPrefix", raw: "-", index: overallIndex });
      } else {
        push({ type: "char", raw: chars[i], index: overallIndex });
      }
    }
    if (stringIndex + 1 !== strings.length) {
      push({ type: "argumentDivider", raw: " ", index: overallIndex });
    }
  }
  return tokens;
}

// src/runner.ts
async function run(ap, strings) {
  const result = await runSafely(ap, strings);
  if (isErr(result)) {
    return result.error.run();
  }
  return result.value;
}
async function runSafely(ap, strings) {
  const hotPath = [];
  const nodes = parseCommon(ap, strings);
  try {
    const result = await ap.run({ nodes, visitedNodes: /* @__PURE__ */ new Set(), hotPath });
    if (isErr(result)) {
      throw new Exit({
        message: errorBox(nodes, result.error.errors, hotPath),
        exitCode: 1,
        into: "stderr"
      });
    }
    return ok(result.value);
  } catch (e) {
    if (e instanceof Exit) {
      return err(e);
    }
    throw e;
  }
}
async function dryRun(ap, strings) {
  const result = await runSafely(ap, strings);
  if (isErr(result)) {
    return err(result.error.dryRun());
  }
  return result;
}
function parse2(ap, strings) {
  const hotPath = [];
  const nodes = parseCommon(ap, strings);
  return ap.parse({ nodes, visitedNodes: /* @__PURE__ */ new Set(), hotPath });
}
function parseCommon(ap, strings) {
  const longFlagKeys = /* @__PURE__ */ new Set();
  const shortFlagKeys = /* @__PURE__ */ new Set();
  const longOptionKeys = /* @__PURE__ */ new Set();
  const shortOptionKeys = /* @__PURE__ */ new Set();
  const registerContext = {
    forceFlagShortNames: shortFlagKeys,
    forceFlagLongNames: longFlagKeys,
    forceOptionShortNames: shortOptionKeys,
    forceOptionLongNames: longOptionKeys
  };
  ap.register(registerContext);
  const tokens = tokenize(strings);
  return parse(tokens, registerContext);
}

// src/restPositionals.ts
function fullRestPositionals(config) {
  return {
    helpTopics() {
      const displayName = config.displayName ?? config.type.displayName ?? "arg";
      return [
        {
          usage: `[...${displayName}]`,
          category: "arguments",
          defaults: [],
          description: config.description ?? config.type.description ?? ""
        }
      ];
    },
    register(_opts) {
    },
    async parse({
      nodes,
      visitedNodes
    }) {
      const positionals = nodes.filter(
        (node) => node.type === "positionalArgument" && !visitedNodes.has(node)
      );
      const results = [];
      const errors = [];
      for (const positional2 of positionals) {
        visitedNodes.add(positional2);
        const decoded = await safeAsync(
          config.type.from(positional2.raw)
        );
        if (isOk(decoded)) {
          results.push(decoded.value);
        } else {
          errors.push({
            nodes: [positional2],
            message: decoded.error.message
          });
        }
      }
      if (errors.length > 0) {
        return err({
          errors
        });
      }
      return ok(results);
    }
  };
}
function restPositionals(config) {
  return fullRestPositionals({
    type: string,
    ...config
  });
}

// src/multiflag.ts
function multiflag(config) {
  return {
    helpTopics() {
      let usage = `--${config.long}`;
      if (config.short) {
        usage += `, -${config.short}`;
      }
      return [
        {
          category: "flags",
          usage,
          defaults: [],
          description: config.description ?? "self explanatory"
        }
      ];
    },
    register(opts) {
      opts.forceFlagLongNames.add(config.long);
      if (config.short) {
        opts.forceFlagShortNames.add(config.short);
      }
    },
    async parse({
      nodes,
      visitedNodes
    }) {
      const options = findOption(nodes, {
        longNames: [config.long],
        shortNames: config.short ? [config.short] : []
      }).filter((x) => !visitedNodes.has(x));
      for (const option2 of options) {
        visitedNodes.add(option2);
      }
      const optionValues = [];
      const errors = [];
      for (const option2 of options) {
        const decoded = await safeAsync(
          boolean2.from(option2.value?.node.raw ?? "true")
        );
        if (isErr(decoded)) {
          errors.push({ nodes: [option2], message: decoded.error.message });
        } else {
          optionValues.push(decoded.value);
        }
      }
      if (errors.length > 0) {
        return err({
          errors
        });
      }
      const multiDecoded = await safeAsync(
        config.type.from(optionValues)
      );
      if (isErr(multiDecoded)) {
        return err({
          errors: [
            {
              nodes: options,
              message: multiDecoded.error.message
            }
          ]
        });
      }
      return multiDecoded;
    }
  };
}

// src/multioption.ts
import chalk8 from "chalk";
function multioption(config) {
  return {
    helpTopics() {
      const displayName = config.type.displayName ?? "value";
      let usage = `--${config.long} <${displayName}>`;
      if (config.short) {
        usage += `, -${config.short}=<${displayName}>`;
      }
      const defaults = [];
      const defaultValueFn = config.defaultValue ?? config.type.defaultValue;
      if (defaultValueFn) {
        try {
          const defaultValue = defaultValueFn();
          if (config.defaultValueIsSerializable ?? config.type.defaultValueIsSerializable) {
            defaults.push(`default: ${chalk8.italic(defaultValue)}`);
          } else {
            defaults.push("[...optional]");
          }
        } catch (e) {
        }
      }
      return [
        {
          category: "options",
          usage,
          defaults,
          description: config.description ?? "self explanatory"
        }
      ];
    },
    register(opts) {
      opts.forceOptionLongNames.add(config.long);
      if (config.short) {
        opts.forceOptionShortNames.add(config.short);
      }
    },
    async parse({
      nodes,
      visitedNodes
    }) {
      const options = findOption(nodes, {
        longNames: [config.long],
        shortNames: config.short ? [config.short] : []
      }).filter((x) => !visitedNodes.has(x));
      const defaultValueFn = config.defaultValue ?? config.type.defaultValue;
      if (options.length === 0 && typeof defaultValueFn === "function") {
        try {
          return ok(defaultValueFn());
        } catch (e) {
          const message = `Failed to resolve default value for '--${config.long}': ${e.message}`;
          return err({
            errors: [
              {
                nodes: [],
                message
              }
            ]
          });
        }
      }
      for (const option2 of options) {
        visitedNodes.add(option2);
      }
      const optionValues = [];
      const errors = [];
      const flagNodes = [];
      for (const option2 of options) {
        const providedValue = option2.value?.node.raw;
        if (providedValue === void 0) {
          flagNodes.push(option2);
          continue;
        }
        optionValues.push(providedValue);
      }
      if (flagNodes.length > 0) {
        errors.push({
          nodes: flagNodes,
          message: "Expected to get a value, found a flag"
        });
      }
      if (errors.length > 0) {
        return err({ errors });
      }
      const multiDecoded = await safeAsync(
        config.type.from(optionValues)
      );
      if (isErr(multiDecoded)) {
        return err({
          errors: [{ nodes: options, message: multiDecoded.error.message }]
        });
      }
      return multiDecoded;
    }
  };
}

// src/union.ts
function union(ts, {
  combineErrors = (errors) => errors.join("\n")
} = {}) {
  const merged = Object.assign({}, ...ts.map((x) => typeDef(x)));
  return {
    ...merged,
    async from(input) {
      const errors = [];
      for (const t of ts) {
        const decoded = await safeAsync(fromFn(t)(input));
        if (isOk(decoded)) {
          return decoded.value;
        }
        errors.push(decoded.error.message);
      }
      throw new Error(combineErrors(errors));
    }
  };
}

// src/oneOf.ts
import { inspect } from "node:util";
function oneOf(literals) {
  const examples = literals.map((x) => inspect(x)).join(", ");
  return {
    async from(str) {
      const value = literals.find((x) => x === str);
      if (!value) {
        throw new Error(`Invalid value '${str}'. Expected one of: ${examples}`);
      }
      return value;
    },
    description: `One of ${examples}`
  };
}

// src/rest.ts
function rest(config) {
  return {
    helpTopics() {
      const displayName = config?.displayName ?? "arg";
      return [
        {
          usage: `[...${displayName}]`,
          category: "arguments",
          defaults: [],
          description: config?.description ?? "catches the rest of the values"
        }
      ];
    },
    register() {
    },
    async parse(context) {
      const visitedNodeIndices = [...context.visitedNodes].map((x) => context.nodes.indexOf(x)).filter((x) => x > -1);
      if (visitedNodeIndices.length === 0) {
        return ok([]);
      }
      const maxIndex = Math.max(...visitedNodeIndices);
      const restItems = context.nodes.slice(maxIndex + 1);
      for (const node of restItems) {
        context.visitedNodes.add(node);
      }
      return ok(restItems.map((x) => x.raw));
    }
  };
}

export {
  extendType,
  number,
  string,
  boolean,
  optional,
  array,
  flag,
  positional,
  subcommands,
  binary,
  command,
  option,
  run,
  runSafely,
  dryRun,
  parse2 as parse,
  restPositionals,
  multiflag,
  multioption,
  union,
  oneOf,
  rest
};
//# sourceMappingURL=chunk-NZGMVZHM.js.map
